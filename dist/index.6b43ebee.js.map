{"mappings":"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","sources":["<anon>","src/js/app.js","node_modules/@formkit/tempo/dist/bundle.mjs","node_modules/@formkit/tempo/src/iso8601.ts","node_modules/@formkit/tempo/src/date.ts","node_modules/@formkit/tempo/src/addDay.ts","node_modules/@formkit/tempo/src/monthEnd.ts","node_modules/@formkit/tempo/src/monthDays.ts","node_modules/@formkit/tempo/src/addMonth.ts","node_modules/@formkit/tempo/src/addYear.ts","node_modules/@formkit/tempo/src/addHour.ts","node_modules/@formkit/tempo/src/addMinute.ts","node_modules/@formkit/tempo/src/addSecond.ts","node_modules/@formkit/tempo/src/common.ts","node_modules/@formkit/tempo/src/ap.ts","node_modules/@formkit/tempo/src/applyOffset.ts","node_modules/@formkit/tempo/src/deviceTZ.ts","node_modules/@formkit/tempo/src/offset.ts","node_modules/@formkit/tempo/src/tzDate.ts","node_modules/@formkit/tempo/src/dayOfYear.ts","node_modules/@formkit/tempo/src/dayEnd.ts","node_modules/@formkit/tempo/src/dayStart.ts","node_modules/@formkit/tempo/src/parts.ts","node_modules/@formkit/tempo/src/removeOffset.ts","node_modules/@formkit/tempo/src/deviceLocale.ts","node_modules/@formkit/tempo/src/format.ts","node_modules/@formkit/tempo/src/formatStr.ts","node_modules/@formkit/tempo/src/fourDigitYear.ts","node_modules/@formkit/tempo/src/hourEnd.ts","node_modules/@formkit/tempo/src/hourStart.ts","node_modules/@formkit/tempo/src/minuteEnd.ts","node_modules/@formkit/tempo/src/minuteStart.ts","node_modules/@formkit/tempo/src/monthStart.ts","node_modules/@formkit/tempo/src/yearDays.ts","node_modules/@formkit/tempo/src/nearestDay.ts","node_modules/@formkit/tempo/src/range.ts","node_modules/@formkit/tempo/src/parse.ts","node_modules/@formkit/tempo/src/sameDay.ts","node_modules/@formkit/tempo/src/sameSecond.ts","node_modules/@formkit/tempo/src/sameMinute.ts","node_modules/@formkit/tempo/src/sameHour.ts","node_modules/@formkit/tempo/src/sameYear.ts","node_modules/@formkit/tempo/src/weekStart.ts","node_modules/@formkit/tempo/src/weekEnd.ts","node_modules/@formkit/tempo/src/yearStart.ts","node_modules/@formkit/tempo/src/yearEnd.ts","node_modules/@formkit/tempo/src/isBefore.ts","node_modules/@formkit/tempo/src/isAfter.ts","node_modules/@formkit/tempo/src/isEqual.ts","node_modules/@formkit/tempo/src/diffMilliseconds.ts","node_modules/@formkit/tempo/src/diffRound.ts","node_modules/@formkit/tempo/src/diffSeconds.ts","node_modules/@formkit/tempo/src/diffMinutes.ts","node_modules/@formkit/tempo/src/diffHours.ts","node_modules/@formkit/tempo/src/diffDays.ts","node_modules/@formkit/tempo/src/diffWeeks.ts","node_modules/@formkit/tempo/src/diffMonths.ts","node_modules/@formkit/tempo/src/diffYears.ts","src/data/events.json"],"sourcesContent":["// src/iso8601.ts\nvar $bf2c1b6c50ba2843$var$iso8601Match = /^([0-9]{4})-([0-1][0-9])(?:-([0-3][0-9]))?(?:[T ]?([0-2][0-9])(?::([0-5][0-9]))?(?::([0-5][0-9]))?)?(?:\\.[0-9]+)?(Z|(?:\\+|\\-)[0-9]{2}:?[0-9]{2})?$/;\nfunction $bf2c1b6c50ba2843$export$b65d57190c224ef2(date2) {\n    const matches = date2.match($bf2c1b6c50ba2843$var$iso8601Match);\n    if (matches) {\n        const month = Number(matches[2]);\n        if (month < 1 || month > 12) return false;\n        matches[3];\n        {\n            const date3 = Number(matches[3]);\n            if (date3 < 1 || date3 > 31) return false;\n        }\n        matches[4];\n        {\n            const hours = Number(matches[4]);\n            if (hours < 0 || hours > 23) return false;\n        }\n        return true;\n    }\n    return false;\n}\n// src/date.ts\nfunction $bf2c1b6c50ba2843$var$normalize(date2) {\n    const matches = date2.match($bf2c1b6c50ba2843$var$iso8601Match);\n    if (matches && typeof matches[4] === \"undefined\") return date2 += \"T00:00:00\";\n    return date2;\n}\nfunction $bf2c1b6c50ba2843$export$324d90190a8b822a(date2) {\n    if (!date2) date2 = /* @__PURE__ */ new Date();\n    if (date2 instanceof Date) {\n        const d = new Date(date2);\n        d.setMilliseconds(0);\n        return d;\n    }\n    date2 = date2.trim();\n    if ($bf2c1b6c50ba2843$export$b65d57190c224ef2(date2)) return new Date($bf2c1b6c50ba2843$var$normalize(date2));\n    throw new Error(`Non ISO 8601 compliant date (${date2}).`);\n}\n// src/addDay.ts\nfunction $bf2c1b6c50ba2843$export$7f5939a990528353(inputDate, count = 1) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setDate(d.getDate() + count);\n    return d;\n}\n// src/monthEnd.ts\nfunction $bf2c1b6c50ba2843$export$781108dca7b1e474(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setDate(1);\n    d.setMonth(d.getMonth() + 1);\n    d.setDate(0);\n    return d;\n}\n// src/monthDays.ts\nfunction $bf2c1b6c50ba2843$export$13278eb206eeafb3(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$781108dca7b1e474(inputDate);\n    return d.getDate();\n}\n// src/addMonth.ts\nfunction $bf2c1b6c50ba2843$export$a8822c9336c7c660(inputDate, count = 1, dateOverflow = false) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    const dayOfMonth = d.getDate();\n    if (!dateOverflow) d.setDate(1);\n    d.setMonth(d.getMonth() + count);\n    if (!dateOverflow) {\n        const daysInMonth = $bf2c1b6c50ba2843$export$13278eb206eeafb3(d);\n        d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth);\n    }\n    return d;\n}\n// src/addYear.ts\nfunction $bf2c1b6c50ba2843$export$24e8f69887bdeec3(inputDate, count = 1, dateOverflow = false) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    const dayOfMonth = d.getDate();\n    if (!dateOverflow) d.setDate(1);\n    d.setFullYear(d.getFullYear() + count);\n    if (!dateOverflow) {\n        const daysInMonth = $bf2c1b6c50ba2843$export$13278eb206eeafb3(d);\n        d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth);\n    }\n    return d;\n}\n// src/addHour.ts\nfunction $bf2c1b6c50ba2843$export$4755c637aac4edd7(inputDate, count = 1) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setHours(d.getHours() + count);\n    return d;\n}\n// src/addMinute.ts\nfunction $bf2c1b6c50ba2843$export$9e80b91f5a3682f1(inputDate, count = 1) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setMinutes(d.getMinutes() + count);\n    return d;\n}\n// src/addSecond.ts\nfunction $bf2c1b6c50ba2843$export$31a60be31a85f9c2(inputDate, count = 1) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setSeconds(d.getSeconds() + count);\n    return d;\n}\n// src/common.ts\nvar $bf2c1b6c50ba2843$var$specDate = \"1999-03-04T02:05:01.000Z\";\nvar $bf2c1b6c50ba2843$var$memoParts = /* @__PURE__ */ new Map();\nvar $bf2c1b6c50ba2843$var$clockAgnostic = [\n    [\n        \"YYYY\",\n        {\n            year: \"numeric\"\n        }\n    ],\n    [\n        \"YY\",\n        {\n            year: \"2-digit\"\n        }\n    ],\n    [\n        \"MMMM\",\n        {\n            month: \"long\"\n        }\n    ],\n    [\n        \"MMM\",\n        {\n            month: \"short\"\n        }\n    ],\n    [\n        \"MM\",\n        {\n            month: \"2-digit\"\n        }\n    ],\n    [\n        \"M\",\n        {\n            month: \"numeric\"\n        }\n    ],\n    [\n        \"DD\",\n        {\n            day: \"2-digit\"\n        }\n    ],\n    [\n        \"D\",\n        {\n            day: \"numeric\"\n        }\n    ],\n    [\n        \"dddd\",\n        {\n            weekday: \"long\"\n        }\n    ],\n    [\n        \"ddd\",\n        {\n            weekday: \"short\"\n        }\n    ],\n    [\n        \"d\",\n        {\n            weekday: \"narrow\"\n        }\n    ],\n    [\n        \"mm\",\n        {\n            minute: \"2-digit\"\n        }\n    ],\n    [\n        \"m\",\n        {\n            minute: \"numeric\"\n        }\n    ],\n    [\n        \"ss\",\n        {\n            second: \"2-digit\"\n        }\n    ],\n    [\n        \"s\",\n        {\n            second: \"numeric\"\n        }\n    ],\n    [\n        \"ZZ\",\n        {\n            timeZoneName: \"long\"\n        }\n    ],\n    [\n        \"Z\",\n        {\n            timeZoneName: \"short\"\n        }\n    ]\n];\nvar $bf2c1b6c50ba2843$var$clock24 = [\n    [\n        \"HH\",\n        {\n            hour: \"2-digit\"\n        }\n    ],\n    [\n        \"H\",\n        {\n            hour: \"numeric\"\n        }\n    ]\n];\nvar $bf2c1b6c50ba2843$var$clock12 = [\n    [\n        \"hh\",\n        {\n            hour: \"2-digit\"\n        }\n    ],\n    [\n        \"h\",\n        {\n            hour: \"numeric\"\n        }\n    ],\n    [\n        \"a\",\n        {\n            dayPeriod: \"narrow\"\n        }\n    ],\n    [\n        \"A\",\n        {\n            dayPeriod: \"narrow\"\n        }\n    ]\n];\nvar $bf2c1b6c50ba2843$var$fixedLength = {\n    DD: 2,\n    HH: 2,\n    MM: 2,\n    YY: 2,\n    YYYY: 4,\n    hh: 2,\n    mm: 2,\n    ss: 2\n};\nfunction $bf2c1b6c50ba2843$var$fixedLengthByOffset(offsetString) {\n    if (/^[+-]\\d{2}:\\d{2}/.test(offsetString)) return 6;\n    if (/^[+-]\\d{4}/.test(offsetString)) return 5;\n    throw new Error(\"Invalid offset format\");\n}\nvar $bf2c1b6c50ba2843$var$genitiveTokens = [\n    \"MMMM\",\n    \"MMM\",\n    \"dddd\",\n    \"ddd\"\n];\nvar $bf2c1b6c50ba2843$var$tokens = /* @__PURE__ */ new Map(/* @__PURE__ */ [\n    ...$bf2c1b6c50ba2843$var$clockAgnostic,\n    ...$bf2c1b6c50ba2843$var$clock24,\n    ...$bf2c1b6c50ba2843$var$clock12\n].map((format2)=>{\n    return [\n        format2[0],\n        format2\n    ];\n}));\nvar $bf2c1b6c50ba2843$var$dayPeriodMap = /* @__PURE__ */ new Map();\nvar $bf2c1b6c50ba2843$var$styles = [\n    \"full\",\n    \"long\",\n    \"medium\",\n    \"short\"\n];\nvar $bf2c1b6c50ba2843$var$two = (n)=>String(n).padStart(2, \"0\");\nvar $bf2c1b6c50ba2843$var$four = (n)=>String(n).padStart(2, \"0\");\nfunction $bf2c1b6c50ba2843$var$normStr(part) {\n    if (part.type === \"literal\") part.value = part.value.normalize(\"NFKC\");\n    return part;\n}\nfunction $bf2c1b6c50ba2843$var$fill(inputDate, parts2, locale, genitive = false, offset2 = null) {\n    const partMap = $bf2c1b6c50ba2843$var$createPartMap(inputDate, parts2, locale, genitive);\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    function value({ partName: partName, partValue: partValue, token: token }) {\n        if (partName === \"literal\") return partValue;\n        const value2 = partMap[partName];\n        if (partName === \"hour\" && token === \"H\") return value2.replace(/^0/, \"\") || \"0\";\n        if ([\n            \"mm\",\n            \"ss\",\n            \"MM\"\n        ].includes(token) && value2.length === 1) return `0${value2}`;\n        if (partName === \"dayPeriod\") {\n            const p = $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(d.getUTCHours() < 12 ? \"am\" : \"pm\", locale);\n            return token === \"A\" ? p.toUpperCase() : p.toLowerCase();\n        }\n        if (partName === \"timeZoneName\") return offset2 != null ? offset2 : $bf2c1b6c50ba2843$var$minsToOffset(-1 * d.getTimezoneOffset(), token);\n        return value2;\n    }\n    return parts2.map((part)=>{\n        return {\n            ...part,\n            value: value(part)\n        };\n    });\n}\nfunction $bf2c1b6c50ba2843$var$createPartMap(inputDate, parts2, locale, genitive = false) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    const hour12 = parts2.filter((part)=>part.hour12);\n    const hour24 = parts2.filter((part)=>!part.hour12);\n    const valueParts = [];\n    const genitiveParts = [];\n    function addValues(requestedParts, hour122 = false) {\n        const preciseLocale = `${locale}-u-hc-${hour122 ? \"h12\" : \"h23\"}`;\n        valueParts.push(...new Intl.DateTimeFormat(preciseLocale, requestedParts.reduce((options, part)=>{\n            if (part.partName === \"literal\") return options;\n            if (genitive && $bf2c1b6c50ba2843$var$genitiveTokens.includes(part.token)) genitiveParts.push(part);\n            return Object.assign(options, part.option);\n        }, {\n            timeZone: \"UTC\"\n        })).formatToParts(d).map($bf2c1b6c50ba2843$var$normStr));\n        if (genitive && genitiveParts.length) for (const part of genitiveParts){\n            let formattedParts = [];\n            switch(part.token){\n                case \"MMMM\":\n                    formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n                        dateStyle: \"long\",\n                        timeZone: \"UTC\"\n                    }).formatToParts(d).map($bf2c1b6c50ba2843$var$normStr);\n                    break;\n                case \"MMM\":\n                    formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n                        dateStyle: \"medium\",\n                        timeZone: \"UTC\"\n                    }).formatToParts(d).map($bf2c1b6c50ba2843$var$normStr);\n                    break;\n            }\n            const genitiveFormattedPart = formattedParts.find((p)=>p.type === part.partName);\n            const index = valueParts.findIndex((p)=>p.type === part.partName);\n            if (genitiveFormattedPart && index > -1) valueParts[index] = genitiveFormattedPart;\n        }\n    }\n    if (hour12.length) addValues(hour12, true);\n    if (hour24.length) addValues(hour24);\n    return valueParts.reduce((map, part)=>{\n        map[part.type] = part.value;\n        return map;\n    }, {});\n}\nfunction $bf2c1b6c50ba2843$var$minsToOffset(timeDiffInMins, token = \"Z\") {\n    const hours = String(Math.floor(Math.abs(timeDiffInMins / 60))).padStart(2, \"0\");\n    const mins = String(Math.abs(timeDiffInMins % 60)).padStart(2, \"0\");\n    const sign = timeDiffInMins < 0 ? \"-\" : \"+\";\n    if (token === \"ZZ\") return `${sign}${hours}${mins}`;\n    return `${sign}${hours}:${mins}`;\n}\nfunction $bf2c1b6c50ba2843$var$offsetToMins(offset2, token) {\n    $bf2c1b6c50ba2843$var$validOffset(offset2, token);\n    const [_, sign, hours, mins] = offset2.match(/([+-])([0-3][0-9]):?([0-6][0-9])/);\n    const offsetInMins = Number(hours) * 60 + Number(mins);\n    return sign === \"+\" ? offsetInMins : -offsetInMins;\n}\nfunction $bf2c1b6c50ba2843$var$validOffset(offset2, token = \"Z\") {\n    const valid = ((token2)=>{\n        switch(token2){\n            case \"Z\":\n                return /^([+-])[0-3][0-9]:[0-6][0-9]$/.test(offset2);\n            case \"ZZ\":\n                return /^([+-])[0-3][0-9][0-6][0-9]$/.test(offset2);\n        }\n    })(token);\n    if (!valid) throw new Error(`Invalid offset: ${offset2}`);\n    return offset2;\n}\nfunction $bf2c1b6c50ba2843$var$escapeTokens(str) {\n    return $bf2c1b6c50ba2843$var$clockAgnostic.concat($bf2c1b6c50ba2843$var$clock24).concat($bf2c1b6c50ba2843$var$clock12).sort((a, b)=>a[0].length > b[0].length ? 1 : -1).reduce((target, part)=>{\n        return target.replace(part[0], `\\\\${part[0]}`);\n    }, str);\n}\nfunction $bf2c1b6c50ba2843$var$isNumeric(part) {\n    return [\n        \"numeric\",\n        \"2-digit\"\n    ].includes(part.partValue);\n}\nfunction $bf2c1b6c50ba2843$var$validate(parts2) {\n    let lastPart = void 0;\n    for (const part of parts2){\n        if (part.partName === \"literal\" && !isNaN(parseFloat(part.partValue))) throw new Error(`Numbers in format (${part.partValue}).`);\n        if (lastPart && lastPart.partName !== \"literal\" && part.partName !== \"literal\") {\n            if (!(lastPart.token in $bf2c1b6c50ba2843$var$fixedLength) && !(part.token in $bf2c1b6c50ba2843$var$fixedLength) && !($bf2c1b6c50ba2843$var$isNumeric(lastPart) && part.token.toLowerCase() === \"a\")) throw new Error(`Illegal adjacent tokens (${lastPart.token}, ${part.token})`);\n        }\n        lastPart = part;\n    }\n    return parts2;\n}\nfunction $bf2c1b6c50ba2843$var$getOffsetFormat(format2) {\n    if (typeof format2 === \"string\") return format2.includes(\"ZZ\") ? \"ZZ\" : \"Z\";\n    return \"time\" in format2 && format2.time === \"full\" ? \"Z\" : \"ZZ\";\n}\n// src/ap.ts\nfunction $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(ampm, locale) {\n    const l = $bf2c1b6c50ba2843$var$dayPeriodMap.get(locale);\n    if (l && l[ampm]) return l[ampm];\n    const specimen = new Date($bf2c1b6c50ba2843$var$specDate);\n    specimen.setUTCHours(ampm === \"am\" ? 5 : 20);\n    const subparts = new Intl.DateTimeFormat(locale, {\n        timeStyle: \"full\",\n        timeZone: \"UTC\",\n        hour12: true\n    }).formatToParts(specimen).map($bf2c1b6c50ba2843$var$normStr);\n    const period = subparts.find((part)=>part.type === \"dayPeriod\");\n    if (period) {\n        const localePeriods = l || {};\n        $bf2c1b6c50ba2843$var$dayPeriodMap.set(locale, Object.assign(localePeriods, {\n            [ampm]: period.value\n        }));\n        return period.value;\n    }\n    return ampm;\n}\n// src/applyOffset.ts\nfunction $bf2c1b6c50ba2843$export$81d2e72c19d98397(dateInput, offset2 = \"+00:00\") {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateInput);\n    const token = (()=>{\n        switch($bf2c1b6c50ba2843$var$fixedLengthByOffset(offset2)){\n            case 5:\n                return \"ZZ\";\n            case 6:\n                return \"Z\";\n        }\n    })();\n    const timeDiffInMins = $bf2c1b6c50ba2843$var$offsetToMins(offset2, token);\n    return new Date(d.getTime() + timeDiffInMins * 60000);\n}\n// src/deviceTZ.ts\nfunction $bf2c1b6c50ba2843$var$deviceTZ() {\n    return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n// src/offset.ts\nfunction $bf2c1b6c50ba2843$var$relativeTime(d, timeZone) {\n    const utcParts = new Intl.DateTimeFormat(\"en-US\", {\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        timeZone: timeZone,\n        hourCycle: \"h23\"\n    }).formatToParts(d).map($bf2c1b6c50ba2843$var$normStr);\n    const parts2 = {};\n    utcParts.forEach((part)=>{\n        parts2[part.type] = part.value;\n    });\n    return /* @__PURE__ */ new Date(`${parts2.year}-${parts2.month}-${parts2.day}T${parts2.hour}:${parts2.minute}:${parts2.second}Z`);\n}\nfunction $bf2c1b6c50ba2843$export$cc800923e997bb8(utcTime, tzA = \"UTC\", tzB = \"device\", timeZoneToken = \"Z\") {\n    var _a;\n    tzB = tzB === \"device\" ? (_a = $bf2c1b6c50ba2843$var$deviceTZ()) != null ? _a : \"utc\" : tzB;\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(utcTime);\n    const timeA = $bf2c1b6c50ba2843$var$relativeTime(d, tzA);\n    const timeB = $bf2c1b6c50ba2843$var$relativeTime(d, tzB);\n    const timeDiffInMins = (timeB.getTime() - timeA.getTime()) / 1e3 / 60;\n    return $bf2c1b6c50ba2843$var$minsToOffset(timeDiffInMins, timeZoneToken);\n}\n// src/tzDate.ts\nfunction $bf2c1b6c50ba2843$export$b3be5876ddaf77c4(inputDate, tz) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    return $bf2c1b6c50ba2843$export$81d2e72c19d98397(d, $bf2c1b6c50ba2843$export$cc800923e997bb8(d, tz));\n}\n// src/dayOfYear.ts\nfunction $bf2c1b6c50ba2843$export$75898a44428fae85(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    return Math.round((new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0).getTime() - new Date(d.getFullYear(), 0, 0).getTime()) / 864e5);\n}\n// src/dayEnd.ts\nfunction $bf2c1b6c50ba2843$export$197c0b024b2f1c14(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setHours(23, 59, 59, 999);\n    return d;\n}\n// src/dayStart.ts\nfunction $bf2c1b6c50ba2843$export$b1218574ff0db63d(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setHours(0, 0, 0);\n    return d;\n}\n// src/parts.ts\nfunction $bf2c1b6c50ba2843$export$6e2410c1d27f06e7(format2, locale) {\n    if ($bf2c1b6c50ba2843$var$styles.includes(format2) || typeof format2 === \"object\") return $bf2c1b6c50ba2843$var$styleParts(format2, locale);\n    let f = format2;\n    let match = 0;\n    const testPattern = (pattern)=>{\n        if (!pattern[2]) pattern[2] = new RegExp(`(.)?(${pattern[0]})`, \"g\");\n        if (pattern[2].test(f)) {\n            let didAdd = 0;\n            f = f.replace(pattern[2], (_, prefix, actualMatch)=>{\n                if (prefix === \"\\\\\") return actualMatch;\n                return `${typeof prefix === \"string\" ? prefix : \"\"}{!${didAdd++ ? match : match++}!}`;\n            });\n            return !!didAdd;\n        }\n        return false;\n    };\n    function validate2(patterns) {\n        const parts3 = patterns.map((part)=>part.partName);\n        const deduped = new Set(parts3);\n        if (parts3.length > deduped.size) throw new Error(`Cannot reuse format tokens.`);\n        return patterns;\n    }\n    function createPart(hour12, [token, option, exp]) {\n        const partName = Object.keys(option)[0];\n        const partValue = option[partName];\n        return {\n            option: option,\n            partName: partName,\n            partValue: partValue,\n            token: token,\n            pattern: exp,\n            hour12: hour12\n        };\n    }\n    const found24Patterns = $bf2c1b6c50ba2843$var$clockAgnostic.filter(testPattern).concat($bf2c1b6c50ba2843$var$clock24.filter(testPattern)).map(createPart.bind(null, false));\n    const parts2 = validate2(found24Patterns.concat($bf2c1b6c50ba2843$var$clock12.filter(testPattern).map(createPart.bind(null, true))));\n    const extractIndex = /^\\{!(\\d+)!\\}$/;\n    return f.split(/(\\{!\\d+!\\})/).map((match2)=>{\n        const hasIndex = match2.match(extractIndex);\n        if (hasIndex) return parts2[Number(hasIndex[1])];\n        return {\n            option: {\n                literal: match2\n            },\n            partName: \"literal\",\n            partValue: match2,\n            token: match2,\n            pattern: new RegExp(\"\"),\n            hour12: false\n        };\n    }).filter((part)=>!(part.partName === \"literal\" && part.partValue === \"\"));\n}\nfunction $bf2c1b6c50ba2843$var$styleParts(format2, locale) {\n    const options = {\n        timeZone: \"UTC\"\n    };\n    if (typeof format2 === \"string\") options.dateStyle = format2;\n    else {\n        if (\"date\" in format2) options.dateStyle = format2.date;\n        if (\"time\" in format2) options.timeStyle = format2.time;\n    }\n    const formatter = new Intl.DateTimeFormat(locale, options);\n    const segments = formatter.formatToParts(new Date($bf2c1b6c50ba2843$var$specDate)).map($bf2c1b6c50ba2843$var$normStr);\n    const hourTypeSegments = formatter.formatToParts(/* @__PURE__ */ new Date(\"1999-04-05T23:05:01.000Z\")).map($bf2c1b6c50ba2843$var$normStr);\n    const hourPart = hourTypeSegments.find((segment)=>segment.type === \"hour\");\n    const hourType = hourPart && hourPart.value === \"23\" ? 24 : 12;\n    return segments.map((part)=>{\n        const partName = part.type;\n        const formatPattern = $bf2c1b6c50ba2843$var$guessPattern(part.type, part.value, locale, part.type === \"hour\" ? hourType : void 0, options);\n        if (formatPattern === void 0) return;\n        const partValue = formatPattern[1][partName];\n        if (!partValue) return;\n        if (!formatPattern[2]) formatPattern[2] = new RegExp(`${formatPattern[0]}`, \"g\");\n        return {\n            option: {\n                [partName]: partValue\n            },\n            partName: partName,\n            partValue: partValue,\n            token: formatPattern[0],\n            pattern: formatPattern[2],\n            hour12: hourType === 12\n        };\n    }).filter((part)=>!!part);\n}\nfunction $bf2c1b6c50ba2843$var$guessPattern(partName, partValue, locale, hour, options) {\n    const l = partValue.length;\n    const n = !isNaN(Number(partValue));\n    let style;\n    switch(partName){\n        case \"year\":\n            return l === 2 ? $bf2c1b6c50ba2843$var$tokens.get(\"YY\") : $bf2c1b6c50ba2843$var$tokens.get(\"YYYY\");\n        case \"month\":\n            if (n) return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"M\") : $bf2c1b6c50ba2843$var$tokens.get(\"MM\");\n            style = $bf2c1b6c50ba2843$var$partStyle(locale, partName, partValue);\n            switch(style){\n                case \"long\":\n                    return $bf2c1b6c50ba2843$var$tokens.get(\"MMMM\");\n                default:\n                    return $bf2c1b6c50ba2843$var$tokens.get(\"MMM\");\n            }\n        case \"day\":\n            return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"D\") : $bf2c1b6c50ba2843$var$tokens.get(\"DD\");\n        case \"weekday\":\n            style = $bf2c1b6c50ba2843$var$partStyle(locale, partName, partValue);\n            switch(style){\n                case \"narrow\":\n                    return $bf2c1b6c50ba2843$var$tokens.get(\"d\");\n                case \"short\":\n                    return $bf2c1b6c50ba2843$var$tokens.get(\"ddd\");\n                default:\n                    return $bf2c1b6c50ba2843$var$tokens.get(\"dddd\");\n            }\n        case \"hour\":\n            if (hour === 12) return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"h\") : $bf2c1b6c50ba2843$var$tokens.get(\"hh\");\n            return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"H\") : $bf2c1b6c50ba2843$var$tokens.get(\"HH\");\n        case \"minute\":\n            return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"m\") : $bf2c1b6c50ba2843$var$tokens.get(\"mm\");\n        case \"second\":\n            return l === 1 ? $bf2c1b6c50ba2843$var$tokens.get(\"s\") : $bf2c1b6c50ba2843$var$tokens.get(\"ss\");\n        case \"dayPeriod\":\n            return /^[A-Z]+$/u.test(partValue) ? $bf2c1b6c50ba2843$var$tokens.get(\"A\") : $bf2c1b6c50ba2843$var$tokens.get(\"a\");\n        case \"literal\":\n            return [\n                partValue,\n                {\n                    literal: partValue\n                },\n                new RegExp(\"\")\n            ];\n        case \"timeZoneName\":\n            return options.timeStyle === \"full\" ? $bf2c1b6c50ba2843$var$tokens.get(\"Z\") : $bf2c1b6c50ba2843$var$tokens.get(\"ZZ\");\n        default:\n            return void 0;\n    }\n}\nfunction $bf2c1b6c50ba2843$var$partStyle(locale, part, value) {\n    if (!$bf2c1b6c50ba2843$var$memoParts.has(locale)) {\n        const date2 = new Date($bf2c1b6c50ba2843$var$specDate);\n        const weekdays = [\n            3,\n            8,\n            9,\n            7,\n            6,\n            4,\n            3\n        ];\n        const parts2 = [\n            \"weekday\",\n            \"month\",\n            \"dayPeriod\"\n        ];\n        const partStyles = [\n            \"long\",\n            \"short\",\n            \"narrow\"\n        ];\n        const formats2 = {};\n        for(let i = 0; i < 12; i++){\n            date2.setMonth(0 + i);\n            if (i in weekdays) date2.setDate(weekdays[i]);\n            date2.setUTCHours(8 + i);\n            for (const style of partStyles){\n                const segments = new Intl.DateTimeFormat(locale, parts2.reduce((options, part2)=>Object.assign(options, {\n                        [part2]: style\n                    }), {\n                    hour12: true,\n                    timeZone: \"UTC\"\n                })).formatToParts(date2).map($bf2c1b6c50ba2843$var$normStr);\n                if (style === \"long\" || style === \"short\") {\n                    const genitiveFormattedParts = new Intl.DateTimeFormat(locale, {\n                        dateStyle: style === \"short\" ? \"medium\" : \"long\",\n                        timeZone: \"UTC\"\n                    }).formatToParts(date2).map($bf2c1b6c50ba2843$var$normStr);\n                    const genitiveMonth = genitiveFormattedParts.find((part2)=>part2.type === \"month\");\n                    const index = segments.findIndex((part2)=>part2.type === \"month\");\n                    if (index > -1 && genitiveMonth) segments[index] = genitiveMonth;\n                }\n                segments.forEach((part2)=>{\n                    if (part2.type === \"literal\") return;\n                    const type = part2.type;\n                    formats2[type] = Object.assign(formats2[type] || {}, {\n                        [part2.value]: style\n                    });\n                });\n            }\n        }\n        $bf2c1b6c50ba2843$var$memoParts.set(locale, formats2);\n    }\n    const formats = $bf2c1b6c50ba2843$var$memoParts.get(locale);\n    return formats ? formats[part][value] : void 0;\n}\n// src/removeOffset.ts\nfunction $bf2c1b6c50ba2843$export$6d0ed9f2778a193a(dateInput, offset2 = \"+00:00\") {\n    const positive = offset2.slice(0, 1) === \"+\";\n    return $bf2c1b6c50ba2843$export$81d2e72c19d98397(dateInput, offset2.replace(positive ? \"+\" : \"-\", positive ? \"-\" : \"+\"));\n}\n// src/deviceLocale.ts\nfunction $bf2c1b6c50ba2843$var$deviceLocale() {\n    return Intl.DateTimeFormat().resolvedOptions().locale;\n}\n// src/format.ts\nfunction $bf2c1b6c50ba2843$export$d9468344d3651243(inputDateOrOptions, format2 = \"long\", locale = \"device\", genitive = false, partFilter) {\n    let tz, forceOffset;\n    if (typeof inputDateOrOptions === \"object\" && !(inputDateOrOptions instanceof Date)) ({ date: inputDateOrOptions, format: format2, locale: locale, genitive: genitive, partFilter: partFilter, tz: tz } = inputDateOrOptions);\n    if (format2 === \"ISO8601\") return $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateOrOptions).toISOString();\n    if (tz) forceOffset = $bf2c1b6c50ba2843$export$cc800923e997bb8(inputDateOrOptions, \"utc\", tz, $bf2c1b6c50ba2843$var$getOffsetFormat(format2));\n    tz != null ? tz : tz = $bf2c1b6c50ba2843$var$deviceTZ();\n    if ((tz == null ? void 0 : tz.toLowerCase()) !== \"utc\") inputDateOrOptions = $bf2c1b6c50ba2843$export$6d0ed9f2778a193a(inputDateOrOptions, $bf2c1b6c50ba2843$export$cc800923e997bb8(inputDateOrOptions, tz, \"utc\"));\n    if (!locale || locale === \"device\") locale = $bf2c1b6c50ba2843$var$deviceLocale();\n    return $bf2c1b6c50ba2843$var$fill(inputDateOrOptions, $bf2c1b6c50ba2843$export$6e2410c1d27f06e7(format2, locale).filter(partFilter != null ? partFilter : ()=>true), locale, genitive, forceOffset).map((p)=>p.value).join(\"\");\n}\n// src/formatStr.ts\nfunction $bf2c1b6c50ba2843$export$5c36e1133fcfd384(format2, locale = \"en\", escapeLiterals = false, filterParts = ()=>true) {\n    return $bf2c1b6c50ba2843$export$6e2410c1d27f06e7(format2, locale).filter(filterParts).reduce((f, p)=>f += escapeLiterals && p.partName === \"literal\" ? $bf2c1b6c50ba2843$var$escapeTokens(p.token) : p.token, \"\").normalize(\"NFKC\");\n}\n// src/fourDigitYear.ts\nfunction $bf2c1b6c50ba2843$export$45d0834b23a18f0a(value) {\n    const y = /* @__PURE__ */ new Date().getFullYear();\n    const currentYear = y % 100;\n    const century = Math.floor(y / 100);\n    const parsedYear = Number(value);\n    return (century + (parsedYear > currentYear + 20 ? -1 : 0)) * 100 + parsedYear;\n}\n// src/hourEnd.ts\nfunction $bf2c1b6c50ba2843$export$9c80acbe4630f5a2(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setMinutes(59, 59, 999);\n    return d;\n}\n// src/hourStart.ts\nfunction $bf2c1b6c50ba2843$export$ad5c3a631ed9f072(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setMinutes(0, 0);\n    return d;\n}\n// src/minuteEnd.ts\nfunction $bf2c1b6c50ba2843$export$657a2c0180b97fce(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setSeconds(59, 999);\n    return d;\n}\n// src/minuteStart.ts\nfunction $bf2c1b6c50ba2843$export$ea6efb4e2b3588ab(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setSeconds(0);\n    return d;\n}\n// src/monthStart.ts\nfunction $bf2c1b6c50ba2843$export$2054124de58b0c47(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setDate(1);\n    d.setHours(0, 0, 0);\n    return d;\n}\n// src/yearDays.ts\nfunction $bf2c1b6c50ba2843$export$22905845d321e4e6(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    return (new Date(d.getFullYear() + 1, 0, 0).getTime() - new Date(d.getFullYear(), 0, 0).getTime()) / 864e5;\n}\n// src/nearestDay.ts\nfunction $bf2c1b6c50ba2843$export$cebb7efafcb4a9ca(inputDate, search, constraint = 7) {\n    let increments;\n    let decrements;\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    switch(constraint){\n        case \"month\":\n            decrements = d.getDate();\n            increments = $bf2c1b6c50ba2843$export$13278eb206eeafb3(d) - d.getDate();\n            break;\n        case \"week\":\n            decrements = d.getDay() + 1;\n            increments = 6 - d.getDay();\n            break;\n        case \"year\":\n            const total = $bf2c1b6c50ba2843$export$22905845d321e4e6(d);\n            const day = $bf2c1b6c50ba2843$export$75898a44428fae85(d);\n            decrements = day;\n            increments = total - day;\n            break;\n        default:\n            increments = decrements = constraint;\n    }\n    for(let i = 0; i <= increments || i < decrements; i++){\n        if (i <= increments) {\n            const next = $bf2c1b6c50ba2843$export$7f5939a990528353(d, i);\n            if (search(next)) return next;\n        }\n        if (i && i <= decrements) {\n            const prev = $bf2c1b6c50ba2843$export$7f5939a990528353(d, -i);\n            if (search(prev)) return prev;\n        }\n    }\n    return null;\n}\n// src/range.ts\nfunction $bf2c1b6c50ba2843$export$d02631cccf789723(token, locale = \"en\", genitive = false) {\n    const r = (n, c)=>Array(n).fill(\"\").map((_, i)=>`${c(i)}`);\n    if (token === \"M\") return r(12, (i)=>i + 1);\n    if (token === \"MM\") return r(12, (i)=>{\n        const m = i + 1;\n        return m < 10 ? `0${m}` : m;\n    });\n    if (token.startsWith(\"M\")) return $bf2c1b6c50ba2843$export$d02631cccf789723(\"MM\").map((m)=>$bf2c1b6c50ba2843$export$d9468344d3651243(`2000-${m}-05`, token, locale, genitive));\n    if (token.startsWith(\"d\")) return r(7, (i)=>`0${i + 2}`).map((d)=>$bf2c1b6c50ba2843$export$d9468344d3651243(`2022-10-${d}`, token, locale));\n    if (token === \"a\") return [\n        $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(\"am\", locale).toLowerCase(),\n        $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(\"pm\", locale).toLowerCase()\n    ];\n    if (token === \"A\") return [\n        $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(\"am\", locale).toUpperCase(),\n        $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(\"pm\", locale).toUpperCase()\n    ];\n    if (token.startsWith(\"Y\")) {\n        const year = /* @__PURE__ */ new Date().getFullYear();\n        return r(120, (i)=>i + 1).reduce((ranges, i)=>{\n            if (i !== \"120\") ranges.push($bf2c1b6c50ba2843$export$d9468344d3651243(`${year + Number(i)}-06-06`, token, locale));\n            ranges.unshift($bf2c1b6c50ba2843$export$d9468344d3651243(`${year - Number(i)}-06-06`, token, locale));\n            return ranges;\n        }, [\n            $bf2c1b6c50ba2843$export$d9468344d3651243(`${year}-06-06`, token, locale)\n        ]);\n    }\n    if (token.startsWith(\"D\")) return r(31, (i)=>`${token === \"DD\" && i < 9 ? \"0\" : \"\"}${i + 1}`);\n    if (token.startsWith(\"H\")) return r(24, (i)=>`${token === \"HH\" && i < 10 ? \"0\" : \"\"}${i}`);\n    if (token.startsWith(\"h\")) return r(12, (i)=>`${token === \"hh\" && i < 9 ? \"0\" : \"\"}${i + 1}`);\n    if (token.startsWith(\"m\") || token.startsWith(\"s\")) return r(60, (i)=>`${token.length > 1 && i < 10 ? \"0\" : \"\"}${i}`);\n    return [];\n}\n// src/parse.ts\nfunction $bf2c1b6c50ba2843$export$98e6a39c04603d36(dateStrOrOptions, format2 = \"ISO8601\", locale = \"device\") {\n    let partFilter = ()=>true;\n    let dateStr;\n    let dateOverflow = \"backward\";\n    if (typeof dateStrOrOptions === \"object\") ({ date: dateStr, format: format2 = \"ISO8601\", locale: locale = \"device\", dateOverflow: dateOverflow = \"backward\", partFilter: partFilter = ()=>true } = dateStrOrOptions);\n    else dateStr = dateStrOrOptions;\n    if (!dateStr) throw new Error(\"parse() requires a date string.\");\n    const invalid = ()=>{\n        throw new Error(`Date (${dateStr}) does not match format (${$bf2c1b6c50ba2843$export$5c36e1133fcfd384(format2, locale)})`);\n    };\n    if (format2 === \"ISO8601\") return $bf2c1b6c50ba2843$export$324d90190a8b822a(dateStr);\n    const genitive = $bf2c1b6c50ba2843$var$styles.includes(format2) || typeof format2 === \"object\";\n    const formatParts = $bf2c1b6c50ba2843$var$validate($bf2c1b6c50ba2843$export$6e2410c1d27f06e7(format2, locale).filter(partFilter));\n    if (!formatParts.length) throw new Error(\"parse() requires a pattern.\");\n    let parsedParts;\n    try {\n        parsedParts = $bf2c1b6c50ba2843$export$95928c105f9a7e7c(dateStr, formatParts);\n    } catch  {\n        return invalid();\n    }\n    const now = /* @__PURE__ */ new Date();\n    const parsed = /* @__PURE__ */ new Map([\n        [\n            \"YYYY\",\n            now.getFullYear()\n        ],\n        [\n            \"MM\",\n            now.getMonth() + 1\n        ],\n        [\n            \"DD\",\n            now.getDate()\n        ],\n        [\n            \"HH\",\n            0\n        ],\n        [\n            \"mm\",\n            0\n        ],\n        [\n            \"ss\",\n            0\n        ]\n    ]);\n    let a = null;\n    let offset2 = \"\";\n    parsedParts.forEach((part)=>{\n        if (part.partName === \"literal\") return;\n        if (part.token === part.value) return invalid();\n        const v = Number(part.value);\n        if (parsed.has(part.token)) parsed.set(part.token, v);\n        else if (part.token === \"YY\") parsed.set(\"YYYY\", $bf2c1b6c50ba2843$export$45d0834b23a18f0a(part.value));\n        else {\n            const t = part.token;\n            if (t.startsWith(\"d\")) return;\n            else if (t === \"D\") parsed.set(\"DD\", v);\n            else if (t === \"H\" || t.startsWith(\"h\")) parsed.set(\"HH\", v);\n            else if (t === \"M\") parsed.set(\"MM\", v);\n            else if (t === \"a\" || t === \"A\") a = part.value.toLowerCase() === $bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5(\"am\", locale).toLowerCase();\n            else if (t === \"Z\" || t === \"ZZ\") offset2 = $bf2c1b6c50ba2843$var$validOffset(part.value, t);\n            else {\n                const values = $bf2c1b6c50ba2843$export$d02631cccf789723(t, locale, genitive);\n                const index = values.indexOf(part.value);\n                if (index !== -1) switch(t){\n                    case \"MMM\":\n                    case \"MMMM\":\n                        parsed.set(\"MM\", index + 1);\n                        break;\n                }\n            }\n        }\n    });\n    let hours = parsed.get(\"HH\") || 0;\n    if (a === false) {\n        hours += hours === 12 ? 0 : 12;\n        parsed.set(\"HH\", hours === 24 ? 0 : hours);\n    } else if (a === true && hours === 12) parsed.set(\"HH\", 0);\n    parsed.set(\"MM\", (parsed.get(\"MM\") || 1) - 1);\n    let [Y, M, D, h, m, s] = Array.from(parsed.values());\n    const maxDaysInMonth = $bf2c1b6c50ba2843$export$13278eb206eeafb3(/* @__PURE__ */ new Date(`${$bf2c1b6c50ba2843$var$four(Y)}-${$bf2c1b6c50ba2843$var$two(M + 1)}-10`));\n    if (maxDaysInMonth < D && dateOverflow === \"throw\") throw new Error(`Invalid date ${$bf2c1b6c50ba2843$var$four(Y)}-${$bf2c1b6c50ba2843$var$two(M + 1)}-${$bf2c1b6c50ba2843$var$two(D)}`);\n    D = dateOverflow === \"backward\" ? Math.min(D, maxDaysInMonth) : D;\n    const isoString = `${$bf2c1b6c50ba2843$var$four(Y)}-${$bf2c1b6c50ba2843$var$two(M + 1)}-${$bf2c1b6c50ba2843$var$two(D)}T${$bf2c1b6c50ba2843$var$two(h)}:${$bf2c1b6c50ba2843$var$two(m)}:${$bf2c1b6c50ba2843$var$two(s)}${offset2}`;\n    const d = new Date(isoString);\n    if (isFinite(+d)) return d;\n    return invalid();\n}\nfunction $bf2c1b6c50ba2843$export$95928c105f9a7e7c(dateStr, formatParts) {\n    let i = 0;\n    const advance = (parts2)=>[\n            parts2[i++],\n            parts2[i]\n        ];\n    let pos = 0;\n    const parsed = [];\n    let n = void 0;\n    do {\n        const [current, next] = advance(formatParts);\n        n = next;\n        let len = 1;\n        if (current.partName === \"literal\") len = current.partValue.length;\n        else if (current.partName === \"timeZoneName\") len = $bf2c1b6c50ba2843$var$fixedLengthByOffset(dateStr.substring(pos));\n        else if (current.token in $bf2c1b6c50ba2843$var$fixedLength) len = $bf2c1b6c50ba2843$var$fixedLength[current.token];\n        else if (next) {\n            if (next.partName === \"literal\") {\n                len = dateStr.indexOf(next.partValue, pos) - pos;\n                if (len < 0) throw new Error();\n            } else if (next.partName === \"dayPeriod\") {\n                for(let i2 = 1; i2 <= 4; i2++)if (isNaN(Number(dateStr.charAt(pos + i2)))) {\n                    len = i2;\n                    break;\n                }\n            } else {\n                const nextChar = dateStr.substring(pos).search(/\\d/);\n                if (nextChar !== -1) len = pos + nextChar;\n            }\n        } else len = dateStr.length;\n        parsed.push({\n            ...current,\n            value: dateStr.substring(pos, pos + len)\n        });\n        pos += len;\n    }while (n);\n    return parsed;\n}\n// src/sameDay.ts\nfunction $bf2c1b6c50ba2843$export$803c6c0e435ba32b(inputDateA, inputDateB) {\n    const a = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateA);\n    const b = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateB);\n    return a.getDate() === b.getDate() && a.getMonth() === b.getMonth() && a.getFullYear() === b.getFullYear();\n}\n// src/sameSecond.ts\nfunction $bf2c1b6c50ba2843$export$5a99176ea6cfebdd(inputDateA, inputDateB) {\n    const a = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateA);\n    const b = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateB);\n    return a.getSeconds() === b.getSeconds();\n}\n// src/sameMinute.ts\nfunction $bf2c1b6c50ba2843$export$fa772f7da5a47fa4(inputDateA, inputDateB) {\n    const a = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateA);\n    const b = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateB);\n    return a.getMinutes() === b.getMinutes();\n}\n// src/sameHour.ts\nfunction $bf2c1b6c50ba2843$export$d8faeb573309cb28(inputDateA, inputDateB) {\n    const a = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateA);\n    const b = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateB);\n    return a.getHours() === b.getHours();\n}\n// src/sameYear.ts\nfunction $bf2c1b6c50ba2843$export$78527fd0f2d4b19(inputDateA, inputDateB) {\n    const a = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateA);\n    const b = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDateB);\n    return a.getFullYear() === b.getFullYear();\n}\n// src/weekStart.ts\nfunction $bf2c1b6c50ba2843$export$a82ba44f2bc80e0d(inputDate, startOfWeekDay = 0) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    let diff = startOfWeekDay - d.getDay();\n    if (diff > 0) diff = diff - 7;\n    d.setDate(d.getDate() + diff);\n    d.setHours(0, 0, 0);\n    return d;\n}\n// src/weekEnd.ts\nfunction $bf2c1b6c50ba2843$export$ae0a124617537c2c(inputDate, startOfWeekDay = 0) {\n    const d = $bf2c1b6c50ba2843$export$a82ba44f2bc80e0d(inputDate, startOfWeekDay);\n    d.setDate(d.getDate() + 6);\n    d.setHours(23, 59, 59);\n    return d;\n}\n// src/yearStart.ts\nfunction $bf2c1b6c50ba2843$export$bd380042168282a6(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setMonth(0);\n    d.setDate(1);\n    d.setHours(0, 0, 0);\n    return d;\n}\n// src/yearEnd.ts\nfunction $bf2c1b6c50ba2843$export$3cc1f20a451f35d(inputDate) {\n    const d = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    d.setMonth(11);\n    d.setDate(31);\n    d.setHours(23, 59, 59, 999);\n    return d;\n}\n// src/isBefore.ts\nfunction $bf2c1b6c50ba2843$export$5c007e10c6929c95(inputDate, dateToCompare) {\n    const _date = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    const _dateToCompare = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateToCompare);\n    return +_date < +_dateToCompare;\n}\n// src/isAfter.ts\nfunction $bf2c1b6c50ba2843$export$e4de839670987035(inputDate, dateToCompare) {\n    const _date = $bf2c1b6c50ba2843$export$324d90190a8b822a(inputDate);\n    const _dateToCompare = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateToCompare);\n    return +_date > +_dateToCompare;\n}\n// src/isEqual.ts\nfunction $bf2c1b6c50ba2843$export$248d38f6296296c5(dateLeft, dateRight) {\n    const _dateLeft = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateLeft);\n    const _dateRight = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateRight);\n    return +_dateLeft === +_dateRight;\n}\n// src/diffMilliseconds.ts\nfunction $bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) {\n    const left = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateA);\n    const right = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateB);\n    return +left - +right;\n}\n// src/diffRound.ts\nfunction $bf2c1b6c50ba2843$var$diffRound(value, method = \"trunc\") {\n    const r = Math[method](value);\n    return r == 0 ? 0 : r;\n}\n// src/diffSeconds.ts\nfunction $bf2c1b6c50ba2843$export$f9eaf1eb1ec95164(dateA, dateB, roundingMethod) {\n    return $bf2c1b6c50ba2843$var$diffRound($bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) / 1e3, roundingMethod);\n}\n// src/diffMinutes.ts\nfunction $bf2c1b6c50ba2843$export$49c90754e1099334(dateA, dateB, roundingMethod) {\n    return $bf2c1b6c50ba2843$var$diffRound($bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) / 6e4, roundingMethod);\n}\n// src/diffHours.ts\nfunction $bf2c1b6c50ba2843$export$d92e991327b1d6cb(dateA, dateB, roundingMethod) {\n    return $bf2c1b6c50ba2843$var$diffRound($bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) / 36e5, // 1000 * 60 * 60\n    roundingMethod);\n}\n// src/diffDays.ts\nfunction $bf2c1b6c50ba2843$export$543488ac006ce21a(dateA, dateB, roundingMethod) {\n    return $bf2c1b6c50ba2843$var$diffRound($bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) / 864e5, // hour * 24\n    roundingMethod);\n}\n// src/diffWeeks.ts\nfunction $bf2c1b6c50ba2843$export$ed3de29d5ce5e9fa(dateA, dateB, roundingMethod) {\n    return $bf2c1b6c50ba2843$var$diffRound($bf2c1b6c50ba2843$export$dfcbea04a13b357d(dateA, dateB) / 6048e5, // day * 7\n    roundingMethod);\n}\n// src/diffMonths.ts\nfunction $bf2c1b6c50ba2843$export$8f976fc3e42d3d98(dateA, dateB) {\n    const l = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateA);\n    const r = $bf2c1b6c50ba2843$export$324d90190a8b822a(dateB);\n    if (l < r) {\n        const rs = $bf2c1b6c50ba2843$export$8f976fc3e42d3d98(r, l);\n        return rs == 0 ? 0 : -rs;\n    }\n    let months = (l.getFullYear() - r.getFullYear()) * 12 + (l.getMonth() - r.getMonth());\n    const ld = l.getDate();\n    const rd = r.getDate();\n    if (ld < rd) {\n        const lm = $bf2c1b6c50ba2843$export$13278eb206eeafb3(l);\n        if (!(lm == ld && lm < rd)) months--;\n    }\n    return months == 0 ? 0 : months;\n}\n// src/diffYears.ts\nfunction $bf2c1b6c50ba2843$export$1b841af353092061(dateA, dateB) {\n    const r = Math.trunc($bf2c1b6c50ba2843$export$8f976fc3e42d3d98(dateA, dateB) / 12);\n    return r == 0 ? 0 : r;\n}\n\n\nvar $c0cccb4b7bc6b97b$exports = {};\n$c0cccb4b7bc6b97b$exports = JSON.parse('{\"events\":[{\"id\":1,\"name\":\"International Basler Cup\",\"location\":\"Basel (SUI)\",\"dateStart\":\"31.05.2024\",\"dateEnd\":\"02.06.2024\",\"link\":\"\"},{\"id\":2,\"name\":\"European Aquatics Championships\",\"location\":\"Belgrade (SRB)\",\"dateStart\":\"17.06.2024\",\"dateEnd\":\"23.06.2024\",\"link\":\"https://www.len.eu/belgrade2024/\"},{\"id\":3,\"name\":\"European Junior Swimming Championships\",\"location\":\"Vilnius (LTU)\",\"dateStart\":\"02.07.2024\",\"dateEnd\":\"07.07.2024\",\"link\":\"\"},{\"id\":4,\"name\":\"Swiss Summer Championships\",\"location\":\"Uster (SUI)\",\"dateStart\":\"11.07.2024\",\"dateEnd\":\"14.07.2024\",\"link\":\"https://scu.ch/sm-50m-uster-2024/\"},{\"id\":5,\"name\":\"Swiss Junior Championships\",\"location\":\"Basel (SUI)\",\"dateStart\":\"18.07.2024\",\"dateEnd\":\"21.07.2024\",\"link\":\"\"},{\"id\":6,\"name\":\"The Olympic Games of Paris 2024\",\"location\":\"Paris (FRA)\",\"dateStart\":\"26.07.2024\",\"dateEnd\":\"11.08.2024\",\"link\":\"\"}]}');\n\n\nconst $388b617130f03bd4$var$date = (0, $bf2c1b6c50ba2843$export$d9468344d3651243)(new Date(), \"MMMM DD, YYYY\");\nconst $388b617130f03bd4$var$day = (0, $bf2c1b6c50ba2843$export$d9468344d3651243)(new Date(), \"dddd\");\nconst $388b617130f03bd4$var$btnAdd = document.getElementById(\"btn-add\");\nconst $388b617130f03bd4$var$btnUpdate = document.getElementById(\"btn-update\");\nlet $388b617130f03bd4$var$data = $c0cccb4b7bc6b97b$exports;\nlet $388b617130f03bd4$var$eventsSection = \"\";\nlet $388b617130f03bd4$var$currentDateEl = document.getElementById(\"currentDate\");\nlet $388b617130f03bd4$var$currentDayEl = document.getElementById(\"currentDay\");\nlet $388b617130f03bd4$var$eventsListEl = document.getElementById(\"eventsList\");\nlet $388b617130f03bd4$var$currentDate = (0, $bf2c1b6c50ba2843$export$98e6a39c04603d36)($388b617130f03bd4$var$date, \"dddd DD MMMM YYYY\");\nlet $388b617130f03bd4$var$eventsLoadingEl = document.getElementById(\"eventsLoading\");\n$388b617130f03bd4$var$currentDayEl.textContent = \"Happy \" + $388b617130f03bd4$var$day + \"!\";\n$388b617130f03bd4$var$currentDateEl.textContent = \"Current Date: \" + $388b617130f03bd4$var$date;\nfunction $388b617130f03bd4$var$listEvents() {\n    $388b617130f03bd4$var$data.events.forEach((event)=>{\n        let eventStartDate = (0, $bf2c1b6c50ba2843$export$98e6a39c04603d36)(event.dateStart, \"DD.MM.YYYY\");\n        let eventEndDate = (0, $bf2c1b6c50ba2843$export$98e6a39c04603d36)(event.dateEnd, \"DD.MM.YYYY\");\n        let startDate = (0, $bf2c1b6c50ba2843$export$d9468344d3651243)(eventStartDate, \"dddd, MMMM DD, YYYY\");\n        let endDate = (0, $bf2c1b6c50ba2843$export$d9468344d3651243)(eventEndDate, \"dddd, MMMM DD, YYYY\");\n        let countdown = (0, $bf2c1b6c50ba2843$export$543488ac006ce21a)(eventStartDate, $388b617130f03bd4$var$currentDate);\n        let daysPassed = (0, $bf2c1b6c50ba2843$export$543488ac006ce21a)(eventEndDate, $388b617130f03bd4$var$currentDate);\n        if (countdown < 0) console.log(event.name + \" ended \" + daysPassed + \" days ago.\");\n        else {\n            $388b617130f03bd4$var$eventsSection = '<section class=\"event event-' + event.id + ' border border-black rounded-xl px-4 py-5 flex justify-between\"><div id=\"eventInfo\">';\n            if (event.link === \"\") $388b617130f03bd4$var$eventsSection += '<h4 class=\"mb-2 text-xl font-normal\">' + event.name + \"</h4>\";\n            else $388b617130f03bd4$var$eventsSection += '<h4 class=\"mb-2 text-xl font-normal hover:font-semibold\"><a href=\"' + event.link + '\" title=\"' + event.name + '\" target=\"_blank\">' + event.name + \"</a></h4>\";\n            $388b617130f03bd4$var$eventsSection += '<p><span class=\"font-medium\">Location:</span> ' + event.location + \"</p>\" + '<p><span class=\"font-medium\">Begin:</span> ' + startDate + \"</p>\" + '<p><span class=\"font-medium\">End:</span> ' + endDate + '</p></div><div id=\"eventCountdown\" class=\"text-center\">';\n            if (countdown === 0) $388b617130f03bd4$var$eventsSection += '<p class=\"font-bold\">Today is the day!</p></div></section>';\n            else if (countdown === 1) $388b617130f03bd4$var$eventsSection += '<p class=\"text-7xl\">' + countdown + '</p><p class=\"font-bold\">day to go</p>' + \"</div></section>\";\n            else $388b617130f03bd4$var$eventsSection += '<p class=\"text-7xl\">' + countdown + '</p><p class=\"font-bold\">days to go</p>' + \"</div></section>\";\n        }\n        $388b617130f03bd4$var$eventsListEl.insertAdjacentHTML(\"beforeend\", $388b617130f03bd4$var$eventsSection);\n    });\n}\nwindow.addEventListener(\"load\", (event)=>{\n    $388b617130f03bd4$var$eventsLoadingEl.classList.remove(\"hidden\");\n    setTimeout(function() {\n        $388b617130f03bd4$var$eventsLoadingEl.classList.add(\"hidden\");\n    }, 1500);\n    setTimeout(function() {\n        $388b617130f03bd4$var$listEvents();\n    }, 2000);\n});\n$388b617130f03bd4$var$btnAdd.addEventListener(\"click\", (event)=>{\n    console.log(\"This button will add a new event\");\n});\n$388b617130f03bd4$var$btnUpdate.addEventListener(\"click\", (event)=>{\n    $388b617130f03bd4$var$eventsSection = \"\";\n    $388b617130f03bd4$var$eventsListEl.textContent = \"\";\n    $388b617130f03bd4$var$eventsLoadingEl.classList.remove(\"hidden\");\n    setTimeout(function() {\n        $388b617130f03bd4$var$eventsLoadingEl.classList.add(\"hidden\");\n    }, 1500);\n    setTimeout(function() {\n        $388b617130f03bd4$var$listEvents();\n    }, 2000);\n});\n\n\n//# sourceMappingURL=index.6b43ebee.js.map\n","import { format, parse, diffDays } from \"@formkit/tempo\";\n\nconst eventsData = require(\"../data/events.json\");\n\nconst date = format(new Date(), \"MMMM DD, YYYY\");\nconst day = format(new Date(), \"dddd\");\nconst btnAdd = document.getElementById(\"btn-add\");\nconst btnUpdate = document.getElementById(\"btn-update\");\nlet data = eventsData;\nlet eventsSection = \"\";\nlet currentDateEl = document.getElementById(\"currentDate\");\nlet currentDayEl = document.getElementById(\"currentDay\");\nlet eventsListEl = document.getElementById(\"eventsList\");\nlet currentDate = parse(date, \"dddd DD MMMM YYYY\");\nlet eventsLoadingEl = document.getElementById(\"eventsLoading\");\n\ncurrentDayEl.textContent = \"Happy \" + day + \"!\";\ncurrentDateEl.textContent = \"Current Date: \" + date;\n\nfunction listEvents() {\n  data.events.forEach(event => {\n    let eventStartDate = parse(event.dateStart, \"DD.MM.YYYY\");\n    let eventEndDate = parse(event.dateEnd, \"DD.MM.YYYY\");\n    let startDate = format(eventStartDate, \"dddd, MMMM DD, YYYY\");\n    let endDate = format(eventEndDate, \"dddd, MMMM DD, YYYY\");\n    let countdown = diffDays(eventStartDate, currentDate);\n    let daysPassed = diffDays(eventEndDate, currentDate);\n\n    if (countdown < 0) {\n      console.log(event.name + \" ended \" + daysPassed + \" days ago.\");\n    } else {\n      eventsSection = '<section class=\"event event-' + event.id + ' border border-black rounded-xl px-4 py-5 flex justify-between\"><div id=\"eventInfo\">';\n\n      if (event.link === \"\") {\n        eventsSection += '<h4 class=\"mb-2 text-xl font-normal\">' + event.name + '</h4>';\n      } else {\n        eventsSection += '<h4 class=\"mb-2 text-xl font-normal hover:font-semibold\"><a href=\"' + event.link + '\" title=\"' + event.name + '\" target=\"_blank\">' + event.name + '</a></h4>';\n      }\n\n      eventsSection += '<p><span class=\"font-medium\">Location:</span> ' + event.location + '</p>' +\n        '<p><span class=\"font-medium\">Begin:</span> ' + startDate + '</p>' +\n        '<p><span class=\"font-medium\">End:</span> ' + endDate + '</p></div><div id=\"eventCountdown\" class=\"text-center\">';\n\n      if (countdown === 0) {\n        eventsSection += '<p class=\"font-bold\">Today is the day!</p></div></section>';\n      } else if (countdown === 1) {\n        eventsSection += '<p class=\"text-7xl\">' + countdown + '</p><p class=\"font-bold\">day to go</p>' + '</div></section>';\n      } else {\n        eventsSection += '<p class=\"text-7xl\">' + countdown + '</p><p class=\"font-bold\">days to go</p>' + '</div></section>';\n      }\n    }\n    eventsListEl.insertAdjacentHTML(\"beforeend\", eventsSection);\n  });\n\n}\n\nwindow.addEventListener(\"load\", event => {\n  eventsLoadingEl.classList.remove(\"hidden\");\n  setTimeout(function() { eventsLoadingEl.classList.add(\"hidden\") }, 1500);\n  setTimeout(function() { listEvents() }, 2000);\n});\n\nbtnAdd.addEventListener(\"click\", event => {\n  console.log(\"This button will add a new event\");\n});\n\nbtnUpdate.addEventListener(\"click\", event => {\n  eventsSection = \"\";\n  eventsListEl.textContent = \"\";\n  eventsLoadingEl.classList.remove(\"hidden\");\n  setTimeout(function() { eventsLoadingEl.classList.add(\"hidden\") }, 1500);\n  setTimeout(function() { listEvents() }, 2000);\n});\n","// src/iso8601.ts\nvar iso8601Match = /^([0-9]{4})-([0-1][0-9])(?:-([0-3][0-9]))?(?:[T ]?([0-2][0-9])(?::([0-5][0-9]))?(?::([0-5][0-9]))?)?(?:\\.[0-9]+)?(Z|(?:\\+|\\-)[0-9]{2}:?[0-9]{2})?$/;\nfunction iso8601(date2) {\n  const matches = date2.match(iso8601Match);\n  if (matches) {\n    const month = Number(matches[2]);\n    if (month < 1 || month > 12)\n      return false;\n    if (typeof matches[3] !== void 0) {\n      const date3 = Number(matches[3]);\n      if (date3 < 1 || date3 > 31)\n        return false;\n    }\n    if (typeof matches[4] !== void 0) {\n      const hours = Number(matches[4]);\n      if (hours < 0 || hours > 23)\n        return false;\n    }\n    return true;\n  }\n  return false;\n}\n\n// src/date.ts\nfunction normalize(date2) {\n  const matches = date2.match(iso8601Match);\n  if (matches && typeof matches[4] === \"undefined\") {\n    return date2 += \"T00:00:00\";\n  }\n  return date2;\n}\nfunction date(date2) {\n  if (!date2) {\n    date2 = /* @__PURE__ */ new Date();\n  }\n  if (date2 instanceof Date) {\n    const d = new Date(date2);\n    d.setMilliseconds(0);\n    return d;\n  }\n  date2 = date2.trim();\n  if (iso8601(date2)) {\n    return new Date(normalize(date2));\n  }\n  throw new Error(`Non ISO 8601 compliant date (${date2}).`);\n}\n\n// src/addDay.ts\nfunction addDay(inputDate, count = 1) {\n  const d = date(inputDate);\n  d.setDate(d.getDate() + count);\n  return d;\n}\n\n// src/monthEnd.ts\nfunction monthEnd(inputDate) {\n  const d = date(inputDate);\n  d.setDate(1);\n  d.setMonth(d.getMonth() + 1);\n  d.setDate(0);\n  return d;\n}\n\n// src/monthDays.ts\nfunction monthDays(inputDate) {\n  const d = monthEnd(inputDate);\n  return d.getDate();\n}\n\n// src/addMonth.ts\nfunction addMonth(inputDate, count = 1, dateOverflow = false) {\n  const d = date(inputDate);\n  const dayOfMonth = d.getDate();\n  if (!dateOverflow)\n    d.setDate(1);\n  d.setMonth(d.getMonth() + count);\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d);\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth);\n  }\n  return d;\n}\n\n// src/addYear.ts\nfunction addYear(inputDate, count = 1, dateOverflow = false) {\n  const d = date(inputDate);\n  const dayOfMonth = d.getDate();\n  if (!dateOverflow)\n    d.setDate(1);\n  d.setFullYear(d.getFullYear() + count);\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d);\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth);\n  }\n  return d;\n}\n\n// src/addHour.ts\nfunction addHour(inputDate, count = 1) {\n  const d = date(inputDate);\n  d.setHours(d.getHours() + count);\n  return d;\n}\n\n// src/addMinute.ts\nfunction addMinute(inputDate, count = 1) {\n  const d = date(inputDate);\n  d.setMinutes(d.getMinutes() + count);\n  return d;\n}\n\n// src/addSecond.ts\nfunction addSecond(inputDate, count = 1) {\n  const d = date(inputDate);\n  d.setSeconds(d.getSeconds() + count);\n  return d;\n}\n\n// src/common.ts\nvar specDate = \"1999-03-04T02:05:01.000Z\";\nvar memoParts = /* @__PURE__ */ new Map();\nvar clockAgnostic = [\n  [\"YYYY\", { year: \"numeric\" }],\n  [\"YY\", { year: \"2-digit\" }],\n  [\"MMMM\", { month: \"long\" }],\n  [\"MMM\", { month: \"short\" }],\n  [\"MM\", { month: \"2-digit\" }],\n  [\"M\", { month: \"numeric\" }],\n  [\"DD\", { day: \"2-digit\" }],\n  [\"D\", { day: \"numeric\" }],\n  [\"dddd\", { weekday: \"long\" }],\n  [\"ddd\", { weekday: \"short\" }],\n  [\"d\", { weekday: \"narrow\" }],\n  [\"mm\", { minute: \"2-digit\" }],\n  [\"m\", { minute: \"numeric\" }],\n  [\"ss\", { second: \"2-digit\" }],\n  [\"s\", { second: \"numeric\" }],\n  [\"ZZ\", { timeZoneName: \"long\" }],\n  [\"Z\", { timeZoneName: \"short\" }]\n];\nvar clock24 = [\n  [\"HH\", { hour: \"2-digit\" }],\n  [\"H\", { hour: \"numeric\" }]\n];\nvar clock12 = [\n  [\"hh\", { hour: \"2-digit\" }],\n  [\"h\", { hour: \"numeric\" }],\n  [\"a\", { dayPeriod: \"narrow\" }],\n  [\"A\", { dayPeriod: \"narrow\" }]\n];\nvar fixedLength = {\n  DD: 2,\n  HH: 2,\n  MM: 2,\n  YY: 2,\n  YYYY: 4,\n  hh: 2,\n  mm: 2,\n  ss: 2\n};\nfunction fixedLengthByOffset(offsetString) {\n  if (/^[+-]\\d{2}:\\d{2}/.test(offsetString)) {\n    return 6;\n  }\n  if (/^[+-]\\d{4}/.test(offsetString)) {\n    return 5;\n  }\n  throw new Error(\"Invalid offset format\");\n}\nvar genitiveTokens = [\"MMMM\", \"MMM\", \"dddd\", \"ddd\"];\nvar tokens = /* @__PURE__ */ new Map(\n  /* @__PURE__ */ [...clockAgnostic, ...clock24, ...clock12].map((format2) => {\n    return [format2[0], format2];\n  })\n);\nvar dayPeriodMap = /* @__PURE__ */ new Map();\nvar styles = [\n  \"full\",\n  \"long\",\n  \"medium\",\n  \"short\"\n];\nvar two = (n) => String(n).padStart(2, \"0\");\nvar four = (n) => String(n).padStart(2, \"0\");\nfunction normStr(part) {\n  if (part.type === \"literal\") {\n    part.value = part.value.normalize(\"NFKC\");\n  }\n  return part;\n}\nfunction fill(inputDate, parts2, locale, genitive = false, offset2 = null) {\n  const partMap = createPartMap(inputDate, parts2, locale, genitive);\n  const d = date(inputDate);\n  function value({ partName, partValue, token }) {\n    if (partName === \"literal\")\n      return partValue;\n    const value2 = partMap[partName];\n    if (partName === \"hour\" && token === \"H\") {\n      return value2.replace(/^0/, \"\") || \"0\";\n    }\n    if ([\"mm\", \"ss\", \"MM\"].includes(token) && value2.length === 1) {\n      return `0${value2}`;\n    }\n    if (partName === \"dayPeriod\") {\n      const p = ap(d.getUTCHours() < 12 ? \"am\" : \"pm\", locale);\n      return token === \"A\" ? p.toUpperCase() : p.toLowerCase();\n    }\n    if (partName === \"timeZoneName\") {\n      return offset2 != null ? offset2 : minsToOffset(-1 * d.getTimezoneOffset(), token);\n    }\n    return value2;\n  }\n  return parts2.map((part) => {\n    return {\n      ...part,\n      value: value(part)\n    };\n  });\n}\nfunction createPartMap(inputDate, parts2, locale, genitive = false) {\n  const d = date(inputDate);\n  const hour12 = parts2.filter((part) => part.hour12);\n  const hour24 = parts2.filter((part) => !part.hour12);\n  const valueParts = [];\n  const genitiveParts = [];\n  function addValues(requestedParts, hour122 = false) {\n    const preciseLocale = `${locale}-u-hc-${hour122 ? \"h12\" : \"h23\"}`;\n    valueParts.push(\n      ...new Intl.DateTimeFormat(\n        preciseLocale,\n        requestedParts.reduce(\n          (options, part) => {\n            if (part.partName === \"literal\")\n              return options;\n            if (genitive && genitiveTokens.includes(part.token)) {\n              genitiveParts.push(part);\n            }\n            return Object.assign(options, part.option);\n          },\n          { timeZone: \"UTC\" }\n        )\n      ).formatToParts(d).map(normStr)\n    );\n    if (genitive && genitiveParts.length) {\n      for (const part of genitiveParts) {\n        let formattedParts = [];\n        switch (part.token) {\n          case \"MMMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"long\",\n              timeZone: \"UTC\"\n            }).formatToParts(d).map(normStr);\n            break;\n          case \"MMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"medium\",\n              timeZone: \"UTC\"\n            }).formatToParts(d).map(normStr);\n            break;\n        }\n        const genitiveFormattedPart = formattedParts.find(\n          (p) => p.type === part.partName\n        );\n        const index = valueParts.findIndex((p) => p.type === part.partName);\n        if (genitiveFormattedPart && index > -1) {\n          valueParts[index] = genitiveFormattedPart;\n        }\n      }\n    }\n  }\n  if (hour12.length)\n    addValues(hour12, true);\n  if (hour24.length)\n    addValues(hour24);\n  return valueParts.reduce((map, part) => {\n    map[part.type] = part.value;\n    return map;\n  }, {});\n}\nfunction minsToOffset(timeDiffInMins, token = \"Z\") {\n  const hours = String(Math.floor(Math.abs(timeDiffInMins / 60))).padStart(\n    2,\n    \"0\"\n  );\n  const mins = String(Math.abs(timeDiffInMins % 60)).padStart(2, \"0\");\n  const sign = timeDiffInMins < 0 ? \"-\" : \"+\";\n  if (token === \"ZZ\") {\n    return `${sign}${hours}${mins}`;\n  }\n  return `${sign}${hours}:${mins}`;\n}\nfunction offsetToMins(offset2, token) {\n  validOffset(offset2, token);\n  const [_, sign, hours, mins] = offset2.match(\n    /([+-])([0-3][0-9]):?([0-6][0-9])/\n  );\n  const offsetInMins = Number(hours) * 60 + Number(mins);\n  return sign === \"+\" ? offsetInMins : -offsetInMins;\n}\nfunction validOffset(offset2, token = \"Z\") {\n  const valid = ((token2) => {\n    switch (token2) {\n      case \"Z\":\n        return /^([+-])[0-3][0-9]:[0-6][0-9]$/.test(offset2);\n      case \"ZZ\":\n        return /^([+-])[0-3][0-9][0-6][0-9]$/.test(offset2);\n    }\n  })(token);\n  if (!valid)\n    throw new Error(`Invalid offset: ${offset2}`);\n  return offset2;\n}\nfunction escapeTokens(str) {\n  return clockAgnostic.concat(clock24).concat(clock12).sort((a, b) => a[0].length > b[0].length ? 1 : -1).reduce((target, part) => {\n    return target.replace(part[0], `\\\\${part[0]}`);\n  }, str);\n}\nfunction isNumeric(part) {\n  return [\"numeric\", \"2-digit\"].includes(part.partValue);\n}\nfunction validate(parts2) {\n  let lastPart = void 0;\n  for (const part of parts2) {\n    if (part.partName === \"literal\" && !isNaN(parseFloat(part.partValue))) {\n      throw new Error(`Numbers in format (${part.partValue}).`);\n    }\n    if (lastPart && lastPart.partName !== \"literal\" && part.partName !== \"literal\") {\n      if (!(lastPart.token in fixedLength) && !(part.token in fixedLength) && !(isNumeric(lastPart) && part.token.toLowerCase() === \"a\")) {\n        throw new Error(\n          `Illegal adjacent tokens (${lastPart.token}, ${part.token})`\n        );\n      }\n    }\n    lastPart = part;\n  }\n  return parts2;\n}\nfunction getOffsetFormat(format2) {\n  if (typeof format2 === \"string\") {\n    return format2.includes(\"ZZ\") ? \"ZZ\" : \"Z\";\n  }\n  return \"time\" in format2 && format2.time === \"full\" ? \"Z\" : \"ZZ\";\n}\n\n// src/ap.ts\nfunction ap(ampm, locale) {\n  const l = dayPeriodMap.get(locale);\n  if (l && l[ampm])\n    return l[ampm];\n  const specimen = new Date(specDate);\n  specimen.setUTCHours(ampm === \"am\" ? 5 : 20);\n  const subparts = new Intl.DateTimeFormat(locale, {\n    timeStyle: \"full\",\n    timeZone: \"UTC\",\n    hour12: true\n  }).formatToParts(specimen).map(normStr);\n  const period = subparts.find((part) => part.type === \"dayPeriod\");\n  if (period) {\n    const localePeriods = l || {};\n    dayPeriodMap.set(\n      locale,\n      Object.assign(localePeriods, { [ampm]: period.value })\n    );\n    return period.value;\n  }\n  return ampm;\n}\n\n// src/applyOffset.ts\nfunction applyOffset(dateInput, offset2 = \"+00:00\") {\n  const d = date(dateInput);\n  const token = (() => {\n    switch (fixedLengthByOffset(offset2)) {\n      case 5:\n        return \"ZZ\";\n      case 6:\n        return \"Z\";\n    }\n  })();\n  const timeDiffInMins = offsetToMins(offset2, token);\n  return new Date(d.getTime() + timeDiffInMins * 1e3 * 60);\n}\n\n// src/deviceTZ.ts\nfunction deviceTZ() {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\n// src/offset.ts\nfunction relativeTime(d, timeZone) {\n  const utcParts = new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZone,\n    hourCycle: \"h23\"\n  }).formatToParts(d).map(normStr);\n  const parts2 = {};\n  utcParts.forEach((part) => {\n    parts2[part.type] = part.value;\n  });\n  return /* @__PURE__ */ new Date(\n    `${parts2.year}-${parts2.month}-${parts2.day}T${parts2.hour}:${parts2.minute}:${parts2.second}Z`\n  );\n}\nfunction offset(utcTime, tzA = \"UTC\", tzB = \"device\", timeZoneToken = \"Z\") {\n  var _a;\n  tzB = tzB === \"device\" ? (_a = deviceTZ()) != null ? _a : \"utc\" : tzB;\n  const d = date(utcTime);\n  const timeA = relativeTime(d, tzA);\n  const timeB = relativeTime(d, tzB);\n  const timeDiffInMins = (timeB.getTime() - timeA.getTime()) / 1e3 / 60;\n  return minsToOffset(timeDiffInMins, timeZoneToken);\n}\n\n// src/tzDate.ts\nfunction tzDate(inputDate, tz) {\n  const d = date(inputDate);\n  return applyOffset(d, offset(d, tz));\n}\n\n// src/dayOfYear.ts\nfunction dayOfYear(inputDate) {\n  const d = date(inputDate);\n  return Math.round(\n    (new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0).getTime() - new Date(d.getFullYear(), 0, 0).getTime()) / 864e5\n  );\n}\n\n// src/dayEnd.ts\nfunction dayEnd(inputDate) {\n  const d = date(inputDate);\n  d.setHours(23, 59, 59, 999);\n  return d;\n}\n\n// src/dayStart.ts\nfunction dayStart(inputDate) {\n  const d = date(inputDate);\n  d.setHours(0, 0, 0);\n  return d;\n}\n\n// src/parts.ts\nfunction parts(format2, locale) {\n  if (styles.includes(format2) || typeof format2 === \"object\") {\n    return styleParts(format2, locale);\n  }\n  let f = format2;\n  let match = 0;\n  const testPattern = (pattern) => {\n    if (!pattern[2])\n      pattern[2] = new RegExp(`(.)?(${pattern[0]})`, \"g\");\n    if (pattern[2].test(f)) {\n      let didAdd = 0;\n      f = f.replace(pattern[2], (_, prefix, actualMatch) => {\n        if (prefix === \"\\\\\")\n          return actualMatch;\n        return `${typeof prefix === \"string\" ? prefix : \"\"}{!${didAdd++ ? match : match++}!}`;\n      });\n      return !!didAdd;\n    }\n    return false;\n  };\n  function validate2(patterns) {\n    const parts3 = patterns.map((part) => part.partName);\n    const deduped = new Set(parts3);\n    if (parts3.length > deduped.size) {\n      throw new Error(`Cannot reuse format tokens.`);\n    }\n    return patterns;\n  }\n  function createPart(hour12, [token, option, exp]) {\n    const partName = Object.keys(option)[0];\n    const partValue = option[partName];\n    return {\n      option,\n      partName,\n      partValue,\n      token,\n      pattern: exp,\n      hour12\n    };\n  }\n  const found24Patterns = clockAgnostic.filter(testPattern).concat(clock24.filter(testPattern)).map(createPart.bind(null, false));\n  const parts2 = validate2(\n    found24Patterns.concat(\n      clock12.filter(testPattern).map(createPart.bind(null, true))\n    )\n  );\n  const extractIndex = /^\\{!(\\d+)!\\}$/;\n  return f.split(/(\\{!\\d+!\\})/).map((match2) => {\n    const hasIndex = match2.match(extractIndex);\n    if (hasIndex) {\n      return parts2[Number(hasIndex[1])];\n    }\n    return {\n      option: { literal: match2 },\n      partName: \"literal\",\n      partValue: match2,\n      token: match2,\n      pattern: new RegExp(\"\"),\n      hour12: false\n    };\n  }).filter((part) => !(part.partName === \"literal\" && part.partValue === \"\"));\n}\nfunction styleParts(format2, locale) {\n  const options = {\n    timeZone: \"UTC\"\n  };\n  if (typeof format2 === \"string\") {\n    options.dateStyle = format2;\n  } else {\n    if (\"date\" in format2)\n      options.dateStyle = format2.date;\n    if (\"time\" in format2)\n      options.timeStyle = format2.time;\n  }\n  const formatter = new Intl.DateTimeFormat(locale, options);\n  const segments = formatter.formatToParts(new Date(specDate)).map(normStr);\n  const hourTypeSegments = formatter.formatToParts(/* @__PURE__ */ new Date(\"1999-04-05T23:05:01.000Z\")).map(normStr);\n  const hourPart = hourTypeSegments.find((segment) => segment.type === \"hour\");\n  const hourType = hourPart && hourPart.value === \"23\" ? 24 : 12;\n  return segments.map((part) => {\n    const partName = part.type;\n    const formatPattern = guessPattern(\n      part.type,\n      part.value,\n      locale,\n      part.type === \"hour\" ? hourType : void 0,\n      options\n    );\n    if (formatPattern === void 0)\n      return;\n    const partValue = formatPattern[1][partName];\n    if (!partValue)\n      return;\n    if (!formatPattern[2])\n      formatPattern[2] = new RegExp(`${formatPattern[0]}`, \"g\");\n    return {\n      option: { [partName]: partValue },\n      partName,\n      partValue,\n      token: formatPattern[0],\n      pattern: formatPattern[2],\n      hour12: hourType === 12\n    };\n  }).filter((part) => !!part);\n}\nfunction guessPattern(partName, partValue, locale, hour, options) {\n  const l = partValue.length;\n  const n = !isNaN(Number(partValue));\n  let style;\n  switch (partName) {\n    case \"year\":\n      return l === 2 ? tokens.get(\"YY\") : tokens.get(\"YYYY\");\n    case \"month\":\n      if (n)\n        return l === 1 ? tokens.get(\"M\") : tokens.get(\"MM\");\n      style = partStyle(locale, partName, partValue);\n      switch (style) {\n        case \"long\":\n          return tokens.get(\"MMMM\");\n        default:\n          return tokens.get(\"MMM\");\n      }\n    case \"day\":\n      return l === 1 ? tokens.get(\"D\") : tokens.get(\"DD\");\n    case \"weekday\":\n      style = partStyle(locale, partName, partValue);\n      switch (style) {\n        case \"narrow\":\n          return tokens.get(\"d\");\n        case \"short\":\n          return tokens.get(\"ddd\");\n        default:\n          return tokens.get(\"dddd\");\n      }\n    case \"hour\":\n      if (hour === 12)\n        return l === 1 ? tokens.get(\"h\") : tokens.get(\"hh\");\n      return l === 1 ? tokens.get(\"H\") : tokens.get(\"HH\");\n    case \"minute\":\n      return l === 1 ? tokens.get(\"m\") : tokens.get(\"mm\");\n    case \"second\":\n      return l === 1 ? tokens.get(\"s\") : tokens.get(\"ss\");\n    case \"dayPeriod\":\n      return /^[A-Z]+$/u.test(partValue) ? tokens.get(\"A\") : tokens.get(\"a\");\n    case \"literal\":\n      return [partValue, { literal: partValue }, new RegExp(\"\")];\n    case \"timeZoneName\":\n      return options.timeStyle === \"full\" ? tokens.get(\"Z\") : tokens.get(\"ZZ\");\n    default:\n      return void 0;\n  }\n}\nfunction partStyle(locale, part, value) {\n  if (!memoParts.has(locale)) {\n    const date2 = new Date(specDate);\n    const weekdays = [3, 8, 9, 7, 6, 4, 3];\n    const parts2 = [\"weekday\", \"month\", \"dayPeriod\"];\n    const partStyles = [\"long\", \"short\", \"narrow\"];\n    const formats2 = {};\n    for (let i = 0; i < 12; i++) {\n      date2.setMonth(0 + i);\n      if (i in weekdays)\n        date2.setDate(weekdays[i]);\n      date2.setUTCHours(8 + i);\n      for (const style of partStyles) {\n        const segments = new Intl.DateTimeFormat(\n          locale,\n          parts2.reduce(\n            (options, part2) => Object.assign(options, { [part2]: style }),\n            { hour12: true, timeZone: \"UTC\" }\n          )\n        ).formatToParts(date2).map(normStr);\n        if (style === \"long\" || style === \"short\") {\n          const genitiveFormattedParts = new Intl.DateTimeFormat(locale, {\n            dateStyle: style === \"short\" ? \"medium\" : \"long\",\n            timeZone: \"UTC\"\n          }).formatToParts(date2).map(normStr);\n          const genitiveMonth = genitiveFormattedParts.find(\n            (part2) => part2.type === \"month\"\n          );\n          const index = segments.findIndex((part2) => part2.type === \"month\");\n          if (index > -1 && genitiveMonth)\n            segments[index] = genitiveMonth;\n        }\n        segments.forEach((part2) => {\n          if (part2.type === \"literal\")\n            return;\n          const type = part2.type;\n          formats2[type] = Object.assign(formats2[type] || {}, {\n            [part2.value]: style\n          });\n        });\n      }\n    }\n    memoParts.set(locale, formats2);\n  }\n  const formats = memoParts.get(locale);\n  return formats ? formats[part][value] : void 0;\n}\n\n// src/removeOffset.ts\nfunction removeOffset(dateInput, offset2 = \"+00:00\") {\n  const positive = offset2.slice(0, 1) === \"+\";\n  return applyOffset(\n    dateInput,\n    offset2.replace(positive ? \"+\" : \"-\", positive ? \"-\" : \"+\")\n  );\n}\n\n// src/deviceLocale.ts\nfunction deviceLocale() {\n  return Intl.DateTimeFormat().resolvedOptions().locale;\n}\n\n// src/format.ts\nfunction format(inputDateOrOptions, format2 = \"long\", locale = \"device\", genitive = false, partFilter) {\n  let tz, forceOffset;\n  if (typeof inputDateOrOptions === \"object\" && !(inputDateOrOptions instanceof Date)) {\n    ;\n    ({\n      date: inputDateOrOptions,\n      format: format2,\n      locale,\n      genitive,\n      partFilter,\n      tz\n    } = inputDateOrOptions);\n  }\n  if (format2 === \"ISO8601\")\n    return date(inputDateOrOptions).toISOString();\n  if (tz) {\n    forceOffset = offset(inputDateOrOptions, \"utc\", tz, getOffsetFormat(format2));\n  }\n  tz != null ? tz : tz = deviceTZ();\n  if ((tz == null ? void 0 : tz.toLowerCase()) !== \"utc\") {\n    inputDateOrOptions = removeOffset(\n      inputDateOrOptions,\n      offset(inputDateOrOptions, tz, \"utc\")\n    );\n  }\n  if (!locale || locale === \"device\") {\n    locale = deviceLocale();\n  }\n  return fill(\n    inputDateOrOptions,\n    parts(format2, locale).filter(partFilter != null ? partFilter : () => true),\n    locale,\n    genitive,\n    forceOffset\n  ).map((p) => p.value).join(\"\");\n}\n\n// src/formatStr.ts\nfunction formatStr(format2, locale = \"en\", escapeLiterals = false, filterParts = () => true) {\n  return parts(format2, locale).filter(filterParts).reduce(\n    (f, p) => f += escapeLiterals && p.partName === \"literal\" ? escapeTokens(p.token) : p.token,\n    \"\"\n  ).normalize(\"NFKC\");\n}\n\n// src/fourDigitYear.ts\nfunction fourDigitYear(value) {\n  const y = (/* @__PURE__ */ new Date()).getFullYear();\n  const currentYear = y % 100;\n  const century = Math.floor(y / 100);\n  const parsedYear = Number(value);\n  return (century + (parsedYear > currentYear + 20 ? -1 : 0)) * 100 + parsedYear;\n}\n\n// src/hourEnd.ts\nfunction hourEnd(inputDate) {\n  const d = date(inputDate);\n  d.setMinutes(59, 59, 999);\n  return d;\n}\n\n// src/hourStart.ts\nfunction hourStart(inputDate) {\n  const d = date(inputDate);\n  d.setMinutes(0, 0);\n  return d;\n}\n\n// src/minuteEnd.ts\nfunction minuteEnd(inputDate) {\n  const d = date(inputDate);\n  d.setSeconds(59, 999);\n  return d;\n}\n\n// src/minuteStart.ts\nfunction minuteStart(inputDate) {\n  const d = date(inputDate);\n  d.setSeconds(0);\n  return d;\n}\n\n// src/monthStart.ts\nfunction monthStart(inputDate) {\n  const d = date(inputDate);\n  d.setDate(1);\n  d.setHours(0, 0, 0);\n  return d;\n}\n\n// src/yearDays.ts\nfunction yearDays(inputDate) {\n  const d = date(inputDate);\n  return (new Date(d.getFullYear() + 1, 0, 0).getTime() - new Date(d.getFullYear(), 0, 0).getTime()) / 864e5;\n}\n\n// src/nearestDay.ts\nfunction nearestDay(inputDate, search, constraint = 7) {\n  let increments;\n  let decrements;\n  const d = date(inputDate);\n  switch (constraint) {\n    case \"month\":\n      decrements = d.getDate();\n      increments = monthDays(d) - d.getDate();\n      break;\n    case \"week\":\n      decrements = d.getDay() + 1;\n      increments = 6 - d.getDay();\n      break;\n    case \"year\":\n      const total = yearDays(d);\n      const day = dayOfYear(d);\n      decrements = day;\n      increments = total - day;\n      break;\n    default:\n      increments = decrements = constraint;\n  }\n  for (let i = 0; i <= increments || i < decrements; i++) {\n    if (i <= increments) {\n      const next = addDay(d, i);\n      if (search(next))\n        return next;\n    }\n    if (i && i <= decrements) {\n      const prev = addDay(d, -i);\n      if (search(prev))\n        return prev;\n    }\n  }\n  return null;\n}\n\n// src/range.ts\nfunction range(token, locale = \"en\", genitive = false) {\n  const r = (n, c) => Array(n).fill(\"\").map((_, i) => `${c(i)}`);\n  if (token === \"M\")\n    return r(12, (i) => i + 1);\n  if (token === \"MM\")\n    return r(12, (i) => {\n      const m = i + 1;\n      return m < 10 ? `0${m}` : m;\n    });\n  if (token.startsWith(\"M\"))\n    return range(\"MM\").map(\n      (m) => format(`2000-${m}-05`, token, locale, genitive)\n    );\n  if (token.startsWith(\"d\"))\n    return r(7, (i) => `0${i + 2}`).map(\n      (d) => format(`2022-10-${d}`, token, locale)\n    );\n  if (token === \"a\")\n    return [ap(\"am\", locale).toLowerCase(), ap(\"pm\", locale).toLowerCase()];\n  if (token === \"A\")\n    return [ap(\"am\", locale).toUpperCase(), ap(\"pm\", locale).toUpperCase()];\n  if (token.startsWith(\"Y\")) {\n    const year = (/* @__PURE__ */ new Date()).getFullYear();\n    return r(120, (i) => i + 1).reduce(\n      (ranges, i) => {\n        if (i !== \"120\")\n          ranges.push(format(`${year + Number(i)}-06-06`, token, locale));\n        ranges.unshift(format(`${year - Number(i)}-06-06`, token, locale));\n        return ranges;\n      },\n      [format(`${year}-06-06`, token, locale)]\n    );\n  }\n  if (token.startsWith(\"D\"))\n    return r(31, (i) => `${token === \"DD\" && i < 9 ? \"0\" : \"\"}${i + 1}`);\n  if (token.startsWith(\"H\"))\n    return r(24, (i) => `${token === \"HH\" && i < 10 ? \"0\" : \"\"}${i}`);\n  if (token.startsWith(\"h\"))\n    return r(12, (i) => `${token === \"hh\" && i < 9 ? \"0\" : \"\"}${i + 1}`);\n  if (token.startsWith(\"m\") || token.startsWith(\"s\"))\n    return r(60, (i) => `${token.length > 1 && i < 10 ? \"0\" : \"\"}${i}`);\n  return [];\n}\n\n// src/parse.ts\nfunction parse(dateStrOrOptions, format2 = \"ISO8601\", locale = \"device\") {\n  let partFilter = () => true;\n  let dateStr;\n  let dateOverflow = \"backward\";\n  if (typeof dateStrOrOptions === \"object\") {\n    ;\n    ({\n      date: dateStr,\n      format: format2 = \"ISO8601\",\n      locale = \"device\",\n      dateOverflow = \"backward\",\n      partFilter = () => true\n    } = dateStrOrOptions);\n  } else {\n    dateStr = dateStrOrOptions;\n  }\n  if (!dateStr)\n    throw new Error(\"parse() requires a date string.\");\n  const invalid = () => {\n    throw new Error(\n      `Date (${dateStr}) does not match format (${formatStr(format2, locale)})`\n    );\n  };\n  if (format2 === \"ISO8601\")\n    return date(dateStr);\n  const genitive = styles.includes(format2) || typeof format2 === \"object\";\n  const formatParts = validate(parts(format2, locale).filter(partFilter));\n  if (!formatParts.length)\n    throw new Error(\"parse() requires a pattern.\");\n  let parsedParts;\n  try {\n    parsedParts = parseParts(dateStr, formatParts);\n  } catch {\n    return invalid();\n  }\n  const now = /* @__PURE__ */ new Date();\n  const parsed = /* @__PURE__ */ new Map([\n    [\"YYYY\", now.getFullYear()],\n    [\"MM\", now.getMonth() + 1],\n    [\"DD\", now.getDate()],\n    [\"HH\", 0],\n    [\"mm\", 0],\n    [\"ss\", 0]\n  ]);\n  let a = null;\n  let offset2 = \"\";\n  parsedParts.forEach((part) => {\n    if (part.partName === \"literal\")\n      return;\n    if (part.token === part.value)\n      return invalid();\n    const v = Number(part.value);\n    if (parsed.has(part.token)) {\n      parsed.set(part.token, v);\n    } else if (part.token === \"YY\") {\n      parsed.set(\"YYYY\", fourDigitYear(part.value));\n    } else {\n      const t = part.token;\n      if (t.startsWith(\"d\")) {\n        return;\n      } else if (t === \"D\") {\n        parsed.set(\"DD\", v);\n      } else if (t === \"H\" || t.startsWith(\"h\")) {\n        parsed.set(\"HH\", v);\n      } else if (t === \"M\") {\n        parsed.set(\"MM\", v);\n      } else if (t === \"a\" || t === \"A\") {\n        a = part.value.toLowerCase() === ap(\"am\", locale).toLowerCase();\n      } else if (t === \"Z\" || t === \"ZZ\") {\n        offset2 = validOffset(part.value, t);\n      } else {\n        const values = range(t, locale, genitive);\n        const index = values.indexOf(part.value);\n        if (index !== -1) {\n          switch (t) {\n            case \"MMM\":\n            case \"MMMM\":\n              parsed.set(\"MM\", index + 1);\n              break;\n          }\n        }\n      }\n    }\n  });\n  let hours = parsed.get(\"HH\") || 0;\n  if (a === false) {\n    hours += hours === 12 ? 0 : 12;\n    parsed.set(\"HH\", hours === 24 ? 0 : hours);\n  } else if (a === true && hours === 12) {\n    parsed.set(\"HH\", 0);\n  }\n  parsed.set(\"MM\", (parsed.get(\"MM\") || 1) - 1);\n  let [Y, M, D, h, m, s] = Array.from(parsed.values());\n  const maxDaysInMonth = monthDays(/* @__PURE__ */ new Date(`${four(Y)}-${two(M + 1)}-10`));\n  if (maxDaysInMonth < D && dateOverflow === \"throw\")\n    throw new Error(`Invalid date ${four(Y)}-${two(M + 1)}-${two(D)}`);\n  D = dateOverflow === \"backward\" ? Math.min(D, maxDaysInMonth) : D;\n  const isoString = `${four(Y)}-${two(M + 1)}-${two(D)}T${two(h)}:${two(\n    m\n  )}:${two(s)}${offset2}`;\n  const d = new Date(isoString);\n  if (isFinite(+d))\n    return d;\n  return invalid();\n}\nfunction parseParts(dateStr, formatParts) {\n  let i = 0;\n  const advance = (parts2) => [\n    parts2[i++],\n    parts2[i]\n  ];\n  let pos = 0;\n  const parsed = [];\n  let n = void 0;\n  do {\n    const [current, next] = advance(formatParts);\n    n = next;\n    let len = 1;\n    if (current.partName === \"literal\") {\n      len = current.partValue.length;\n    } else if (current.partName === \"timeZoneName\") {\n      len = fixedLengthByOffset(dateStr.substring(pos));\n    } else if (current.token in fixedLength) {\n      len = fixedLength[current.token];\n    } else if (next) {\n      if (next.partName === \"literal\") {\n        len = dateStr.indexOf(next.partValue, pos) - pos;\n        if (len < 0)\n          throw new Error();\n      } else if (next.partName === \"dayPeriod\") {\n        for (let i2 = 1; i2 <= 4; i2++) {\n          if (isNaN(Number(dateStr.charAt(pos + i2)))) {\n            len = i2;\n            break;\n          }\n        }\n      } else {\n        const nextChar = dateStr.substring(pos).search(/\\d/);\n        if (nextChar !== -1)\n          len = pos + nextChar;\n      }\n    } else {\n      len = dateStr.length;\n    }\n    parsed.push({ ...current, value: dateStr.substring(pos, pos + len) });\n    pos += len;\n  } while (n);\n  return parsed;\n}\n\n// src/sameDay.ts\nfunction sameDay(inputDateA, inputDateB) {\n  const a = date(inputDateA);\n  const b = date(inputDateB);\n  return a.getDate() === b.getDate() && a.getMonth() === b.getMonth() && a.getFullYear() === b.getFullYear();\n}\n\n// src/sameSecond.ts\nfunction sameSecond(inputDateA, inputDateB) {\n  const a = date(inputDateA);\n  const b = date(inputDateB);\n  return a.getSeconds() === b.getSeconds();\n}\n\n// src/sameMinute.ts\nfunction sameMinute(inputDateA, inputDateB) {\n  const a = date(inputDateA);\n  const b = date(inputDateB);\n  return a.getMinutes() === b.getMinutes();\n}\n\n// src/sameHour.ts\nfunction sameHour(inputDateA, inputDateB) {\n  const a = date(inputDateA);\n  const b = date(inputDateB);\n  return a.getHours() === b.getHours();\n}\n\n// src/sameYear.ts\nfunction sameYear(inputDateA, inputDateB) {\n  const a = date(inputDateA);\n  const b = date(inputDateB);\n  return a.getFullYear() === b.getFullYear();\n}\n\n// src/weekStart.ts\nfunction weekStart(inputDate, startOfWeekDay = 0) {\n  const d = date(inputDate);\n  let diff = startOfWeekDay - d.getDay();\n  if (diff > 0)\n    diff = diff - 7;\n  d.setDate(d.getDate() + diff);\n  d.setHours(0, 0, 0);\n  return d;\n}\n\n// src/weekEnd.ts\nfunction weekEnd(inputDate, startOfWeekDay = 0) {\n  const d = weekStart(inputDate, startOfWeekDay);\n  d.setDate(d.getDate() + 6);\n  d.setHours(23, 59, 59);\n  return d;\n}\n\n// src/yearStart.ts\nfunction yearStart(inputDate) {\n  const d = date(inputDate);\n  d.setMonth(0);\n  d.setDate(1);\n  d.setHours(0, 0, 0);\n  return d;\n}\n\n// src/yearEnd.ts\nfunction yearEnd(inputDate) {\n  const d = date(inputDate);\n  d.setMonth(11);\n  d.setDate(31);\n  d.setHours(23, 59, 59, 999);\n  return d;\n}\n\n// src/isBefore.ts\nfunction isBefore(inputDate, dateToCompare) {\n  const _date = date(inputDate);\n  const _dateToCompare = date(dateToCompare);\n  return +_date < +_dateToCompare;\n}\n\n// src/isAfter.ts\nfunction isAfter(inputDate, dateToCompare) {\n  const _date = date(inputDate);\n  const _dateToCompare = date(dateToCompare);\n  return +_date > +_dateToCompare;\n}\n\n// src/isEqual.ts\nfunction isEqual(dateLeft, dateRight) {\n  const _dateLeft = date(dateLeft);\n  const _dateRight = date(dateRight);\n  return +_dateLeft === +_dateRight;\n}\n\n// src/diffMilliseconds.ts\nfunction diffMilliseconds(dateA, dateB) {\n  const left = date(dateA);\n  const right = date(dateB);\n  return +left - +right;\n}\n\n// src/diffRound.ts\nfunction diffRound(value, method = \"trunc\") {\n  const r = Math[method](value);\n  return r == 0 ? 0 : r;\n}\n\n// src/diffSeconds.ts\nfunction diffSeconds(dateA, dateB, roundingMethod) {\n  return diffRound(diffMilliseconds(dateA, dateB) / 1e3, roundingMethod);\n}\n\n// src/diffMinutes.ts\nfunction diffMinutes(dateA, dateB, roundingMethod) {\n  return diffRound(diffMilliseconds(dateA, dateB) / 6e4, roundingMethod);\n}\n\n// src/diffHours.ts\nfunction diffHours(dateA, dateB, roundingMethod) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 36e5,\n    // 1000 * 60 * 60\n    roundingMethod\n  );\n}\n\n// src/diffDays.ts\nfunction diffDays(dateA, dateB, roundingMethod) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 864e5,\n    // hour * 24\n    roundingMethod\n  );\n}\n\n// src/diffWeeks.ts\nfunction diffWeeks(dateA, dateB, roundingMethod) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 6048e5,\n    // day * 7\n    roundingMethod\n  );\n}\n\n// src/diffMonths.ts\nfunction diffMonths(dateA, dateB) {\n  const l = date(dateA);\n  const r = date(dateB);\n  if (l < r) {\n    const rs = diffMonths(r, l);\n    return rs == 0 ? 0 : -rs;\n  }\n  let months = (l.getFullYear() - r.getFullYear()) * 12 + (l.getMonth() - r.getMonth());\n  const ld = l.getDate();\n  const rd = r.getDate();\n  if (ld < rd) {\n    const lm = monthDays(l);\n    if (!(lm == ld && lm < rd)) {\n      months--;\n    }\n  }\n  return months == 0 ? 0 : months;\n}\n\n// src/diffYears.ts\nfunction diffYears(dateA, dateB) {\n  const r = Math.trunc(diffMonths(dateA, dateB) / 12);\n  return r == 0 ? 0 : r;\n}\nexport {\n  addDay,\n  addHour,\n  addMinute,\n  addMonth,\n  addSecond,\n  addYear,\n  ap,\n  applyOffset,\n  date,\n  dayEnd,\n  dayOfYear,\n  dayStart,\n  diffDays,\n  diffHours,\n  diffMilliseconds,\n  diffMinutes,\n  diffMonths,\n  diffSeconds,\n  diffWeeks,\n  diffYears,\n  format,\n  formatStr,\n  fourDigitYear,\n  hourEnd,\n  hourStart,\n  isAfter,\n  isBefore,\n  isEqual,\n  iso8601,\n  minuteEnd,\n  minuteStart,\n  monthDays,\n  monthEnd,\n  monthStart,\n  nearestDay,\n  offset,\n  parse,\n  parseParts,\n  parts,\n  range,\n  removeOffset,\n  sameDay,\n  sameHour,\n  sameMinute,\n  sameSecond,\n  sameYear,\n  tzDate,\n  weekEnd,\n  weekStart,\n  yearDays,\n  yearEnd,\n  yearStart\n};\n//# sourceMappingURL=bundle.mjs.map","/**\n * Matches a given date with ISO 8601 compliance. Allows the \"T\" to be missing\n * and only requires year and month, other params are required with increasing\n * specificity.\n */\nexport const iso8601Match =\n  /^([0-9]{4})-([0-1][0-9])(?:-([0-3][0-9]))?(?:[T ]?([0-2][0-9])(?::([0-5][0-9]))?(?::([0-5][0-9]))?)?(?:\\.[0-9]+)?(Z|(?:\\+|\\-)[0-9]{2}:?[0-9]{2})?$/\n\n/**\n * True when the date string is valid ISO 8601.\n * @param date - A date string.\n */\nexport function iso8601(date: string): boolean {\n  const matches = date.match(iso8601Match)\n  if (matches) {\n    const month = Number(matches[2])\n    if (month < 1 || month > 12) return false\n\n    if (typeof matches[3] !== undefined) {\n      const date = Number(matches[3])\n      if (date < 1 || date > 31) return false\n    }\n    if (typeof matches[4] !== undefined) {\n      const hours = Number(matches[4])\n      if (hours < 0 || hours > 23) return false\n    }\n\n    return true\n  }\n  return false\n}\n","import { iso8601, iso8601Match } from \"./iso8601\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Normalizes a \"short\" date like 2012-01-01 to 2012-01-01T00:00:00 to prevent\n * automatic coercion to UTC.\n * @param date - A string representation of the date.\n */\nfunction normalize(date: string) {\n  const matches = date.match(iso8601Match)\n  if (matches && typeof matches[4] === \"undefined\") {\n    return (date += \"T00:00:00\")\n  }\n  return date\n}\n\n/**\n * A date to parse.\n * @param date - A Date object or an ISO 8601 date.\n */\nexport function date(date?: DateInput): Date {\n  if (!date) {\n    date = new Date()\n  }\n  if (date instanceof Date) {\n    const d = new Date(date)\n    d.setMilliseconds(0)\n    return d\n  }\n  date = date.trim()\n  if (iso8601(date)) {\n    return new Date(normalize(date))\n  }\n  throw new Error(`Non ISO 8601 compliant date (${date}).`)\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n days after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addDay(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setDate(d.getDate() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the last day of\n * the current month. Does not change the time.\n * @param inputDate - A string or Date object\n */\nexport function monthEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setDate(1)\n  d.setMonth(d.getMonth() + 1)\n  d.setDate(0)\n  return d\n}\n","import { monthEnd } from \"./monthEnd\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns the total number of days from a given month.\n * @param inputDate - A string or Date object\n */\nexport function monthDays(inputDate: DateInput): number {\n  const d = monthEnd(inputDate)\n  return d.getDate()\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n months after the original one. Keep in mind if you\n * start with a date late in a given month you could get a date after the next\n * month.\n * @param inputDate - A date to increment by 1 or more months.\n * @param count - The quantity to add.\n * @param dateOverflow - Whether or not to allow the date to overflow to another month if the inputDates month is out of range of the new month.\n */\nexport function addMonth(\n  inputDate: DateInput,\n  count = 1,\n  dateOverflow = false\n) {\n  const d = date(inputDate)\n  const dayOfMonth = d.getDate()\n  // If overflowing is disallowed, set the date back to the first of the month\n  if (!dateOverflow) d.setDate(1)\n  d.setMonth(d.getMonth() + count)\n\n  // If overflowing is disallowed, we need to set the date back to the proper\n  // day or the last day of the month.\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d)\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth)\n  }\n  return d\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n years after the original one. Keep in mind if\n * you start with a date late in a given month you could get a date after the\n * next month.\n * @param inputDate - A date to increment by 1 day.\n * @param count - The quantity of years add.\n * @param dateOverflow - Whether or not to allow the date to overflow to another month if the inputDates month is out of range of the new month.\n */\nexport function addYear(inputDate: DateInput, count = 1, dateOverflow = false) {\n  const d = date(inputDate)\n  const dayOfMonth = d.getDate()\n  // If overflowing is disallowed, set the date back to the first of the month\n  if (!dateOverflow) d.setDate(1)\n\n  d.setFullYear(d.getFullYear() + count)\n\n  // If overflowing is disallowed, we need to set the date back to the proper\n  // day or the last day of the month.\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d)\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth)\n  }\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n hours after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addHour(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setHours(d.getHours() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n seconds after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addMinute(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setMinutes(d.getMinutes() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n seconds after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addSecond(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setSeconds(d.getSeconds() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport { ap } from \"./ap\"\nimport type {\n  DateInput,\n  NamedFormats,\n  FormatPattern,\n  FormatStyle,\n  Part,\n  FilledPart,\n  Format,\n} from \"./types\"\n\n/**\n * A date to use for determining various spec details.\n */\nexport const specDate = \"1999-03-04T02:05:01.000Z\"\n\n/**\n * A cache of Intl tokens and their respective formats.\n */\nexport const memoParts: Map<string, NamedFormats> = new Map()\n\n/**\n * Clock agnostic time format patterns.\n */\nexport const clockAgnostic: FormatPattern[] = [\n  [\"YYYY\", { year: \"numeric\" }],\n  [\"YY\", { year: \"2-digit\" }],\n  [\"MMMM\", { month: \"long\" }],\n  [\"MMM\", { month: \"short\" }],\n  [\"MM\", { month: \"2-digit\" }],\n  [\"M\", { month: \"numeric\" }],\n  [\"DD\", { day: \"2-digit\" }],\n  [\"D\", { day: \"numeric\" }],\n  [\"dddd\", { weekday: \"long\" }],\n  [\"ddd\", { weekday: \"short\" }],\n  [\"d\", { weekday: \"narrow\" }],\n  [\"mm\", { minute: \"2-digit\" }],\n  [\"m\", { minute: \"numeric\" }],\n  [\"ss\", { second: \"2-digit\" }],\n  [\"s\", { second: \"numeric\" }],\n  [\"ZZ\", { timeZoneName: \"long\" }],\n  [\"Z\", { timeZoneName: \"short\" }],\n]\n\n/**\n * Timezone tokens.\n */\nconst timeZoneTokens = [\"Z\", \"ZZ\"] as const\n\n/**\n * Timezone token type.\n */\nexport type TimezoneToken = (typeof timeZoneTokens)[number]\n\n/**\n * 24 hour click format patterns.\n */\nexport const clock24: FormatPattern[] = [\n  [\"HH\", { hour: \"2-digit\" }],\n  [\"H\", { hour: \"numeric\" }],\n]\n\n/**\n * 12 hour format patterns.\n */\nexport const clock12: FormatPattern[] = [\n  [\"hh\", { hour: \"2-digit\" }],\n  [\"h\", { hour: \"numeric\" }],\n  [\"a\", { dayPeriod: \"narrow\" }],\n  [\"A\", { dayPeriod: \"narrow\" }],\n]\n\n/**\n * Tokens that have a fixed length.\n */\nexport const fixedLength = {\n  DD: 2,\n  HH: 2,\n  MM: 2,\n  YY: 2,\n  YYYY: 4,\n  hh: 2,\n  mm: 2,\n  ss: 2,\n}\n\n/**\n * token Z can have variable length depending on the actual value, so it's\n */\nexport function fixedLengthByOffset(offsetString: string): 6 | 5 {\n  // starts with [+-]xx:xx\n  if (/^[+-]\\d{2}:\\d{2}/.test(offsetString)) {\n    return 6\n  }\n\n  // starts with [+-]xxxx\n  if (/^[+-]\\d{4}/.test(offsetString)) {\n    return 5\n  }\n\n  throw new Error(\"Invalid offset format\")\n}\n\n/**\n * Tokens that are genitive in that they can have \"possession\" when used in\n * a date phrase, \"Marchs 4th day\" (but not in english).\n *\n * When computing a range for these, the range can be either genitive or not.\n * The same is true for parsing dates containing these tokens.\n */\nexport const genitiveTokens = [\"MMMM\", \"MMM\", \"dddd\", \"ddd\"]\n\n/**\n * A map of FormatPattern tuples to their respective token.\n */\nexport const tokens = /* @__PURE__ */ new Map(\n  /* @__PURE__ */ [...clockAgnostic, ...clock24, ...clock12].map((format) => {\n    return [format[0], format]\n  })\n)\n\n/**\n * A map of locales am/pm.\n */\nexport const dayPeriodMap: Map<string, { am?: string; pm?: string }> = new Map()\n\n/**\n * An array of all available date styles.\n */\nexport const styles: ReadonlyArray<FormatStyle> = [\n  \"full\",\n  \"long\",\n  \"medium\",\n  \"short\",\n]\n\n/**\n * Creates a leading zero string of 2 digits.\n * @param n - A number.\n */\nexport const two = (n: number) => String(n).padStart(2, \"0\")\n/**\n * Creates a leading zero string of 4 digits.\n * @param n - A number.\n */\nexport const four = (n: number) => String(n).padStart(2, \"0\")\n\n/**\n * Normalizes a given part to NFKC.\n * @param part - The part to normalize.\n */\nexport function normStr(\n  part: Intl.DateTimeFormatPart\n): Intl.DateTimeFormatPart {\n  if (part.type === \"literal\") {\n    part.value = part.value.normalize(\"NFKC\")\n  }\n  return part\n}\n\n/**\n * Returns the parts filled with pertinent values.\n * @param inputDate - The date to fill parts for\n * @param parts - An array of parts to fill\n * @param locale - The locale to fill with.\n * @param genitive - Whether to use genitive tokens values or not.\n * @param offset - The explicit offset to fill with (ignores the dates true offset).\n */\nexport function fill(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false,\n  offset: string | null = null\n): FilledPart[] {\n  const partMap = createPartMap(inputDate, parts, locale, genitive)\n  const d = date(inputDate)\n\n  /**\n   * Not all values get returned \"properly\" as our tokens would suggest. For\n   * example, at times Intl returns leading zeros when it shouldn't. This fn\n   * is used to clean up those irregular values.\n   * @param param - Part\n   */\n  function value({ partName, partValue, token }: Part) {\n    if (partName === \"literal\") return partValue\n    const value = partMap[partName]\n    if (partName === \"hour\" && token === \"H\") {\n      return value.replace(/^0/, \"\") || \"0\"\n    }\n    if ([\"mm\", \"ss\", \"MM\"].includes(token) && value.length === 1) {\n      // Some tokens are supposed to have leading zeros, but Intl doesn't\n      // always return them, depending on the locale and the format.\n      return `0${value}`\n    }\n    if (partName === \"dayPeriod\") {\n      const p = ap(d.getUTCHours() < 12 ? \"am\" : \"pm\", locale)\n      return token === \"A\" ? p.toUpperCase() : p.toLowerCase()\n    }\n    if (partName === \"timeZoneName\") {\n      return offset ?? minsToOffset(-1 * d.getTimezoneOffset(), token)\n    }\n    return value\n  }\n\n  return parts.map((part): FilledPart => {\n    return {\n      ...part,\n      value: value(part),\n    }\n  })\n}\n\n/**\n * Creates a map of part names to their respective values.\n * @param inputDate - The date to format\n * @param parts - The individual parts the need to be formatted.\n * @param locale - The locale to format the parts with.\n * @param genitive - Whether to use genitive tokens values or not.\n */\nfunction createPartMap(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false\n): Record<keyof Intl.DateTimeFormatPartTypesRegistry, string> {\n  const d = date(inputDate)\n  const hour12 = parts.filter((part) => part.hour12)\n  const hour24 = parts.filter((part) => !part.hour12)\n  const valueParts: Intl.DateTimeFormatPart[] = []\n  const genitiveParts: Part[] = []\n\n  function addValues(requestedParts: Part[], hour12 = false) {\n    const preciseLocale = `${locale}-u-hc-${hour12 ? \"h12\" : \"h23\"}`\n    valueParts.push(\n      ...new Intl.DateTimeFormat(\n        preciseLocale,\n        requestedParts.reduce(\n          (options, part) => {\n            if (part.partName === \"literal\") return options\n            // Side effect! Genitive parts get shoved into a separate array.\n            if (genitive && genitiveTokens.includes(part.token)) {\n              genitiveParts.push(part)\n            }\n            return Object.assign(options, part.option)\n          },\n          { timeZone: \"UTC\" } as Intl.DateTimeFormatOptions\n        )\n      )\n        .formatToParts(d)\n        .map(normStr)\n    )\n    if (genitive && genitiveParts.length) {\n      for (const part of genitiveParts) {\n        let formattedParts: Intl.DateTimeFormatPart[] = []\n        switch (part.token) {\n          case \"MMMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"long\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n          case \"MMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"medium\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n        }\n        const genitiveFormattedPart = formattedParts.find(\n          (p) => p.type === part.partName\n        )\n        const index = valueParts.findIndex((p) => p.type === part.partName)\n        if (genitiveFormattedPart && index > -1) {\n          valueParts[index] = genitiveFormattedPart\n        }\n      }\n    }\n  }\n\n  if (hour12.length) addValues(hour12, true)\n  if (hour24.length) addValues(hour24)\n\n  return valueParts.reduce((map, part) => {\n    map[part.type] = part.value\n    return map\n  }, {} as Record<keyof Intl.DateTimeFormatPartTypesRegistry, string>)\n}\n\n/**\n * Converts minutes (300) to an ISO8601 compatible offset (+0400 or +04:00).\n * @param timeDiffInMins - The difference in minutes between two timezones.\n * @returns\n */\nexport function minsToOffset(\n  timeDiffInMins: number,\n  token: string = \"Z\"\n): string {\n  const hours = String(Math.floor(Math.abs(timeDiffInMins / 60))).padStart(\n    2,\n    \"0\"\n  )\n  const mins = String(Math.abs(timeDiffInMins % 60)).padStart(2, \"0\")\n  const sign = timeDiffInMins < 0 ? \"-\" : \"+\"\n\n  if (token === \"ZZ\") {\n    return `${sign}${hours}${mins}`\n  }\n\n  return `${sign}${hours}:${mins}`\n}\n\n/**\n * Converts an offset (-0500) to minutes (-300).\n * @param offset - The offset to convert to minutes.\n * @param token - The timezone token format.\n */\nexport function offsetToMins(offset: string, token: TimezoneToken): number {\n  validOffset(offset, token)\n  const [_, sign, hours, mins] = offset.match(\n    /([+-])([0-3][0-9]):?([0-6][0-9])/\n  )!\n  const offsetInMins = Number(hours) * 60 + Number(mins)\n  return sign === \"+\" ? offsetInMins : -offsetInMins\n}\n\n/**\n * Validates that an offset is valid according to the format:\n * [+-]HHmm or [+-]HH:mm\n * @param offset - The offset to validate.\n * @param token - The timezone token format.\n */\nexport function validOffset(offset: string, token: TimezoneToken = \"Z\") {\n  const valid = ((token: TimezoneToken): boolean => {\n    switch (token) {\n      case \"Z\":\n        return /^([+-])[0-3][0-9]:[0-6][0-9]$/.test(offset)\n      case \"ZZ\":\n        return /^([+-])[0-3][0-9][0-6][0-9]$/.test(offset)\n    }\n  })(token)\n\n  if (!valid) throw new Error(`Invalid offset: ${offset}`)\n  return offset\n}\n\n/**\n * Given a string of tokens, escape any characters that are tokens.\n * @param str - The string to escape tokens in.\n * @returns The escaped string.\n */\nexport function escapeTokens(str: string): string {\n  return clockAgnostic\n    .concat(clock24)\n    .concat(clock12)\n    .sort((a, b) => (a[0].length > b[0].length ? 1 : -1))\n    .reduce((target, part) => {\n      return target.replace(part[0], `\\\\${part[0]}`)\n    }, str)\n}\n\n/**\n * Checks if a given part should have a numeric value.\n * @param part - A part to check\n */\nexport function isNumeric(part: Part) {\n  return [\"numeric\", \"2-digit\"].includes(part.partValue)\n}\n\n/**\n * Validates that an array of Parts can be parsed.\n * @param parts - Parts to validate for parsing ability.\n */\nexport function validate(parts: Part[]): Part[] | never {\n  let lastPart: Part | undefined = undefined\n  for (const part of parts) {\n    if (part.partName === \"literal\" && !isNaN(parseFloat(part.partValue))) {\n      throw new Error(`Numbers in format (${part.partValue}).`)\n    }\n    if (\n      lastPart &&\n      lastPart.partName !== \"literal\" &&\n      part.partName !== \"literal\"\n    ) {\n      if (\n        !(lastPart.token in fixedLength) &&\n        !(part.token in fixedLength) &&\n        !(isNumeric(lastPart) && part.token.toLowerCase() === \"a\")\n      ) {\n        throw new Error(\n          `Illegal adjacent tokens (${lastPart.token}, ${part.token})`\n        )\n      }\n    }\n    lastPart = part\n  }\n  return parts\n}\n\n/**\n * Returns the timezone token format from a given format.\n * @param format - The format to check.\n * @returns The timezone token format (\"Z\" or \"ZZ\").\n */\nexport function getOffsetFormat(format: Format): TimezoneToken {\n  if (typeof format === \"string\") {\n    return format.includes(\"ZZ\") ? \"ZZ\" : \"Z\"\n  }\n  return \"time\" in format && format.time === \"full\" ? \"Z\" : \"ZZ\"\n}\n","import { dayPeriodMap, specDate, normStr } from \"./common\"\n\n/**\n * Determines the correct value for am/pm by locale and memoizes it.\n * @param ampm - am or pm\n * @param locale - The locale to fetch.\n */\nexport function ap(ampm: \"am\" | \"pm\", locale: string): string {\n  const l = dayPeriodMap.get(locale)\n  if (l && l[ampm]) return l[ampm] as string\n  const specimen = new Date(specDate)\n  specimen.setUTCHours(ampm === \"am\" ? 5 : 20)\n  const subparts = new Intl.DateTimeFormat(locale, {\n    timeStyle: \"full\",\n    timeZone: \"UTC\",\n    hour12: true,\n  })\n    .formatToParts(specimen)\n    .map(normStr)\n  const period = subparts.find((part) => part.type === \"dayPeriod\")\n  if (period) {\n    const localePeriods: { am?: string; pm?: string } = l || {}\n    dayPeriodMap.set(\n      locale,\n      Object.assign(localePeriods, { [ampm]: period.value })\n    )\n    return period.value\n  }\n  return ampm\n}\n","import { date } from \"./date\"\nimport { TimezoneToken, fixedLengthByOffset, offsetToMins } from \"./common\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Apply a given offset to a date, returning a new date with the offset\n * applied by adding or subtracting the given number of minutes.\n * @param dateInput - The date to apply the offset to.\n * @param offset - The offset to apply in the +-HHmm or +-HH:mm format.\n */\nexport function applyOffset(dateInput: DateInput, offset = \"+00:00\"): Date {\n  const d = date(dateInput)\n  const token = ((): TimezoneToken => {\n    switch (fixedLengthByOffset(offset)) {\n      case 5:\n        return \"ZZ\"\n      case 6:\n        return \"Z\"\n    }\n  })()\n  const timeDiffInMins = offsetToMins(offset, token)\n  return new Date(d.getTime() + timeDiffInMins * 1000 * 60)\n}\n","/**\n * Get the timezone of the device.\n *\n * * Note: If the environment variable TZ is not set, it will return undefined.\n */\nexport function deviceTZ(): string | undefined {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone as string | undefined\n}\n","import { date } from \"./date\"\nimport { normStr, minsToOffset, TimezoneToken } from \"./common\"\nimport { deviceTZ } from \"./deviceTZ\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Converts a date object from one timezone to that same time in UTC. This is\n * only for internal use.\n * @param d - A Date object\n * @param timeZone - A timezone string\n */\nfunction relativeTime(d: Date, timeZone: string): Date {\n  const utcParts = new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZone,\n    hourCycle: \"h23\",\n  })\n    .formatToParts(d)\n    .map(normStr)\n  const parts: {\n    year?: string\n    month?: string\n    day?: string\n    hour?: string\n    minute?: string\n    second?: string\n  } = {}\n  utcParts.forEach((part) => {\n    parts[part.type as keyof typeof parts] = part.value\n  })\n  return new Date(\n    `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}Z`\n  )\n}\n\n/**\n * Returns the offset between two timezones on a given date. The results are\n * ISO8601 compatible offsets like -0800 or +0530.\n *\n * @param dateInput - The date on which to determine the offset.\n * @param tzA - (default: UTC) The second timezone to compare determine the offset between.\n * @param tzB - (default: device) The first timezone to compare determine the offset between.\n */\nexport function offset(\n  utcTime: DateInput,\n  tzA = \"UTC\",\n  tzB = \"device\",\n  timeZoneToken: TimezoneToken = \"Z\" ,\n): string {\n  tzB = tzB === \"device\" ? deviceTZ() ?? \"utc\" : tzB\n  const d = date(utcTime)\n  const timeA = relativeTime(d, tzA)\n  const timeB = relativeTime(d, tzB)\n  const timeDiffInMins = (timeB.getTime() - timeA.getTime()) / 1000 / 60\n  return minsToOffset(timeDiffInMins, timeZoneToken)\n}\n","import { offset } from \"./offset\"\nimport { applyOffset } from \"./applyOffset\"\nimport { date } from \"./date\"\nimport { DateInput } from \"./types\"\n\n/**\n * Creates a date object for the input date at the given timezone. For example\n * `tzDate(\"2017-05-06T12:00\", \"Europe/Amsterdam\")` will return a date object\n * for 2017-05-06T10:00:00Z since 12:00 in Amsterdam is 10:00Z.\n *\n * If given a Date object it will use local time and convert it to the given\n * timezone, thus \"changing\" the date.\n * @param inputDate - An iso8601 date string with no timezone\n * @param tz - A timezone string\n */\nexport function tzDate(inputDate: DateInput, tz: string) {\n  const d = date(inputDate)\n  return applyOffset(d, offset(d, tz))\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Gets the what day of the year a given date is. For example, August 1st is\n * the 213th day of the year on non- years and 214th on leap years.\n * @param inputDate - The input date.\n */\nexport function dayOfYear(inputDate: DateInput): number {\n  const d = date(inputDate)\n  return Math.round(\n    (new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0).getTime() -\n      new Date(d.getFullYear(), 0, 0).getTime()) /\n      86400000\n  )\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given day.\n * @param inputDate - A string or Date object\n */\nexport function dayEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setHours(23, 59, 59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given day.\n * @param inputDate - A string or Date object\n */\nexport function dayStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import {\n  styles,\n  normStr,\n  tokens,\n  memoParts,\n  clockAgnostic,\n  clock24,\n  specDate,\n  clock12,\n} from \"./common\"\nimport type {\n  ParseOptions,\n  Format,\n  Part,\n  FormatStyle,\n  FormatStyleObj,\n  FormatPattern,\n  NamedFormats,\n  NamedFormatOption,\n} from \"./types\"\n/**\n * Given a format string, produce an array of matching \"parts\", each part\n * contains a regular expression and the corresponding\n * Intl.DateTimeFormatPartTypesRegistry key/value.\n * @param format - A format string like MM/DD/YYYY\n * @param locale - The locale to parse for.\n */\nexport function parts(format: Format, locale: string): Part[] {\n  if (styles.includes(format as FormatStyle) || typeof format === \"object\") {\n    return styleParts(format as FormatStyle | FormatStyleObj, locale)\n  }\n  let f = format\n  let match = 0\n  const testPattern = (pattern: FormatPattern) => {\n    if (!pattern[2]) pattern[2] = new RegExp(`(.)?(${pattern[0]})`, \"g\")\n    if (pattern[2].test(f)) {\n      let didAdd = 0\n      f = f.replace(pattern[2], (_, prefix, actualMatch) => {\n        if (prefix === \"\\\\\") return actualMatch\n        return `${typeof prefix === \"string\" ? prefix : \"\"}{!${\n          didAdd++ ? match : match++\n        }!}`\n      })\n      return !!didAdd\n    }\n    return false\n  }\n\n  function validate(patterns: Part[]): Part[] {\n    const parts = patterns.map((part) => part.partName)\n    const deduped = new Set(parts)\n    if (parts.length > deduped.size) {\n      throw new Error(`Cannot reuse format tokens.`)\n    }\n    return patterns\n  }\n\n  function createPart(\n    hour12: boolean,\n    [token, option, exp]: FormatPattern\n  ): Part {\n    const partName = Object.keys(option)[0] as Intl.DateTimeFormatPartTypes\n    const partValue = option[partName] as string\n    return {\n      option,\n      partName,\n      partValue,\n      token,\n      pattern: exp as RegExp,\n      hour12,\n    }\n  }\n\n  const found24Patterns = clockAgnostic\n    .filter(testPattern)\n    .concat(clock24.filter(testPattern))\n    .map(createPart.bind(null, false))\n\n  // Reset the format before re-checking\n  const parts = validate(\n    found24Patterns.concat(\n      clock12.filter(testPattern).map(createPart.bind(null, true))\n    )\n  )\n  const extractIndex = /^\\{!(\\d+)!\\}$/\n  return f\n    .split(/(\\{!\\d+!\\})/)\n    .map((match: string): Part => {\n      const hasIndex = match.match(extractIndex)\n      if (hasIndex) {\n        return parts[Number(hasIndex[1])]\n      }\n      return {\n        option: { literal: match },\n        partName: \"literal\",\n        partValue: match,\n        token: match,\n        pattern: new RegExp(\"\"),\n        hour12: false,\n      }\n    })\n    .filter((part) => !(part.partName === \"literal\" && part.partValue === \"\"))\n}\n\n/**\n * Determines the parts in a native date style, like \"full\".\n * @param format - A date style like \"full\" or \"short\"\n * @param locale - The locale string\n */\nfunction styleParts(\n  format: FormatStyle | FormatStyleObj,\n  locale: string\n): Part[] {\n  const options: Intl.DateTimeFormatOptions = {\n    timeZone: \"UTC\",\n  }\n  if (typeof format === \"string\") {\n    options.dateStyle = format\n  } else {\n    if (\"date\" in format) options.dateStyle = format.date\n    if (\"time\" in format) options.timeStyle = format.time\n  }\n\n  const formatter = new Intl.DateTimeFormat(locale, options)\n  const segments = formatter.formatToParts(new Date(specDate)).map(normStr)\n  const hourTypeSegments = formatter\n    .formatToParts(new Date(\"1999-04-05T23:05:01.000Z\"))\n    .map(normStr)\n  const hourPart = hourTypeSegments.find((segment) => segment.type === \"hour\")\n  const hourType = hourPart && hourPart.value === \"23\" ? 24 : 12\n  return segments\n    .map((part): Part | undefined => {\n      const partName = part.type\n      const formatPattern = guessPattern(\n        part.type,\n        part.value,\n        locale,\n        part.type === \"hour\" ? hourType : undefined,\n        options\n      )\n      if (formatPattern === undefined) return\n      const partValue = formatPattern[1][partName]\n      if (!partValue) return\n      if (!formatPattern[2])\n        formatPattern[2] = new RegExp(`${formatPattern[0]}`, \"g\")\n      return {\n        option: { [partName]: partValue },\n        partName,\n        partValue,\n        token: formatPattern[0],\n        pattern: formatPattern[2],\n        hour12: hourType === 12,\n      }\n    })\n    .filter((part): part is Part => !!part)\n}\n\n/**\n * Attempts to guess the correct part value type for a given dateStyle. For\n * example a month of 02 would be \"2-digit\".\n *\n * @param partName - The part name to guess for, like 'year' or 'month'\n * @param partValue - The current value, it is assumed this is the smallest denom.\n */\nfunction guessPattern<T extends Intl.DateTimeFormatPartTypes>(\n  partName: T,\n  partValue: string,\n  locale: string,\n  hour: T extends \"hour\" ? 12 | 24 : undefined,\n  options: Intl.DateTimeFormatOptions\n): FormatPattern | undefined {\n  const l = partValue.length\n  const n = !isNaN(Number(partValue))\n  let style: NamedFormatOption | undefined\n  /* eslint-disable @typescript-eslint/no-non-null-assertion */\n  switch (partName) {\n    case \"year\":\n      return l === 2 ? tokens.get(\"YY\") : tokens.get(\"YYYY\")\n    case \"month\":\n      if (n) return l === 1 ? tokens.get(\"M\") : tokens.get(\"MM\")\n      style = partStyle(locale, partName, partValue)\n      switch (style) {\n        case \"long\":\n          return tokens.get(\"MMMM\")\n        default:\n          return tokens.get(\"MMM\")\n      }\n    case \"day\":\n      return l === 1 ? tokens.get(\"D\") : tokens.get(\"DD\")\n    case \"weekday\":\n      style = partStyle(locale, partName, partValue)\n      switch (style) {\n        case \"narrow\":\n          return tokens.get(\"d\")\n        case \"short\":\n          return tokens.get(\"ddd\")\n        default:\n          return tokens.get(\"dddd\")\n      }\n    case \"hour\":\n      // Need to distinguish the locales default as 24 or 12 hour.\n      if (hour === 12) return l === 1 ? tokens.get(\"h\") : tokens.get(\"hh\")\n      return l === 1 ? tokens.get(\"H\") : tokens.get(\"HH\")\n    case \"minute\":\n      return l === 1 ? tokens.get(\"m\") : tokens.get(\"mm\")\n    case \"second\":\n      return l === 1 ? tokens.get(\"s\") : tokens.get(\"ss\")\n    case \"dayPeriod\":\n      return /^[A-Z]+$/u.test(partValue) ? tokens.get(\"A\") : tokens.get(\"a\")\n    case \"literal\":\n      return [partValue, { literal: partValue }, new RegExp(\"\")]\n    case \"timeZoneName\":\n      return options.timeStyle === \"full\" ? tokens.get(\"Z\") : tokens.get(\"ZZ\")\n    default:\n      return undefined\n  }\n  /* eslint-enable @typescript-eslint/no-non-null-assertion */\n}\n\n/**\n * Determines what \"style\" a given part is in. For example, if you provide:\n * ```js\n * partStyle('en', 'month', 'Jan')\n * // returns \"short\".\n * ```\n * Part styles are always expected to be \"genitive\"  for use in \"dateStyle\".\n * @param locale - Locale string\n * @param part - The part to attempt a lookup on\n * @param value - The value of a given part.\n */\nfunction partStyle(\n  locale: string,\n  part: keyof NamedFormats,\n  value: string\n): NamedFormatOption | undefined {\n  if (!memoParts.has(locale)) {\n    const date = new Date(specDate)\n    const weekdays = [3, 8, 9, 7, 6, 4, 3]\n    const parts = [\"weekday\", \"month\", \"dayPeriod\"]\n    const partStyles: NamedFormatOption[] = [\"long\", \"short\", \"narrow\"]\n    const formats: Partial<NamedFormats> = {}\n    for (let i = 0; i < 12; i++) {\n      date.setMonth(0 + i)\n      if (i in weekdays) date.setDate(weekdays[i])\n      date.setUTCHours(8 + i)\n      for (const style of partStyles) {\n        const segments = new Intl.DateTimeFormat(\n          locale,\n          parts.reduce(\n            (options, part) => Object.assign(options, { [part]: style }),\n            { hour12: true, timeZone: \"UTC\" }\n          )\n        )\n          .formatToParts(date)\n          .map(normStr)\n        if (style === \"long\" || style === \"short\") {\n          const genitiveFormattedParts = new Intl.DateTimeFormat(locale, {\n            dateStyle: style === \"short\" ? \"medium\" : \"long\",\n            timeZone: \"UTC\",\n          })\n            .formatToParts(date)\n            .map(normStr)\n          const genitiveMonth = genitiveFormattedParts.find(\n            (part) => part.type === \"month\"\n          )\n          const index = segments.findIndex((part) => part.type === \"month\")\n          if (index > -1 && genitiveMonth) segments[index] = genitiveMonth\n        }\n        segments.forEach((part) => {\n          if (part.type === \"literal\") return\n          const type = part.type as keyof NamedFormats\n          formats[type] = Object.assign(formats[type] || {}, {\n            [part.value]: style,\n          })\n        })\n      }\n    }\n    memoParts.set(locale, formats as NamedFormats)\n  }\n  const formats = memoParts.get(locale)\n  return formats ? formats[part][value] : undefined\n}\n","import { applyOffset } from \"./applyOffset\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Inverts the offset and applies it to the given date, returning a new date.\n * @param dateInput - The date to remove the offset from.\n * @param offset - The offset to remove in the +-HHmm or +-HH:mm format.\n */\nexport function removeOffset(dateInput: DateInput, offset = \"+00:00\"): Date {\n  const positive = offset.slice(0, 1) === \"+\"\n  return applyOffset(\n    dateInput,\n    offset.replace(positive ? \"+\" : \"-\", positive ? \"-\" : \"+\")\n  )\n}\n","/**\n * Returns the device's locale. This is a simple proxy of the\n * `Intl.DateTimeFormat().resolvedOptions().locale` call.\n */\nexport function deviceLocale() {\n  return Intl.DateTimeFormat().resolvedOptions().locale\n}\n","import { date } from \"./date\"\nimport { parts } from \"./parts\"\nimport { fill, getOffsetFormat } from \"./common\"\nimport type { DateInput, Format, FormatOptions, FormatStyle, Part } from \"./types\"\nimport { offset } from \"./offset\"\nimport { removeOffset } from \"./removeOffset\"\nimport { deviceLocale } from \"./deviceLocale\"\nimport { deviceTZ } from \"./deviceTZ\"\n\n/**\n * Produce a formatted string. Available strings:\n * token | description\n * ------|------------\n * YY | 2 digit year\n * YYYY | 4 digit year\n * M | The month 1-12\n * MM | The month 01-12\n * MMM | Short name Jan-Dec\n * MMMM | Full name January | December\n * D | The day of the month 1-31\n * DD | The day of the month 01-31\n * d | Single digit day \"T\"\n * ddd | Short day name Thu\n * dddd | Full day name Wednesday\n * H | Minimum hour digits, 24 hour, 0-23\n * HH | 2 hour digits, 24 hour, 00-23\n * h | Minimum hour digits, 12 hour clock, 1-12\n * hh | 2 hour digits, 12 hour clock, 01-12\n * m | The minute 0-59\n * mm | The minute 00-59\n * s | The second 0-59\n * ss | The second 00-59\n * a | am/pm\n * A | AM/PM\n * Z | +0800, +0530, -1345\n *\n * @param inputDate - A date object or ISO 8601 string\n * @param format - A format\n */\nexport function format(options: FormatOptions): string\nexport function format(\n  inputDate: DateInput,\n  format?: Format,\n  locale?: string,\n  genitive?: boolean,\n  partFilter?: (part: Part) => boolean\n): string\nexport function format(\n  inputDateOrOptions: DateInput | FormatOptions,\n  format: Format = \"long\",\n  locale: string | undefined = \"device\",\n  genitive: boolean | undefined = false,\n  partFilter?: (part: Part) => boolean\n): string {\n  let tz: string | undefined, forceOffset: string | undefined\n\n  if (\n    typeof inputDateOrOptions === \"object\" &&\n    !(inputDateOrOptions instanceof Date)\n  ) {\n    // Extract options from the object.\n    ;({\n      date: inputDateOrOptions,\n      format,\n      locale,\n      genitive,\n      partFilter,\n      tz,\n    } = inputDateOrOptions)\n  }\n  // ISO 8601 is a special case because it doesn't require a format.\n  if (format === \"ISO8601\") return date(inputDateOrOptions).toISOString()\n\n  if (tz) {\n    forceOffset = offset(inputDateOrOptions, \"utc\", tz, getOffsetFormat(format))\n  }\n\n  // We need to apply an offset to the date so that it can be formatted as UTC.\n  tz ??= deviceTZ()\n  if (tz?.toLowerCase() !== \"utc\") {\n    inputDateOrOptions = removeOffset(\n      inputDateOrOptions,\n      offset(inputDateOrOptions, tz, \"utc\")\n    )\n  }\n\n  if (!locale || locale === \"device\") {\n    locale = deviceLocale()\n  }\n\n  return fill(\n    inputDateOrOptions,\n    parts(format, locale).filter(partFilter ?? (() => true)),\n    locale,\n    genitive,\n    forceOffset\n  )\n    .map((p) => p.value)\n    .join(\"\")\n}\n","import { parts } from \"./parts\"\nimport { escapeTokens } from \"./common\"\nimport type { Format, Part } from \"./types\"\n\n/**\n * Return the string format for a given format. For example:\n * ```js\n * formatStr({ date: 'long' }, 'en') // dddd, MMMM D, YYYY\n * ```\n * @param format - A format string or object.\n * @param locale - A locale or en by default.\n */\nexport function formatStr(\n  format: Format,\n  locale = \"en\",\n  escapeLiterals = false,\n  filterParts: (part: Part) => boolean = () => true\n): string {\n  return parts(format, locale)\n    .filter(filterParts)\n    .reduce(\n      (f, p) =>\n        (f +=\n          escapeLiterals && p.partName === \"literal\"\n            ? escapeTokens(p.token)\n            : p.token),\n      \"\"\n    )\n    .normalize(\"NFKC\")\n}\n","/**\n * Converts a 2 digit year into a 4 digit year. This function assumes years 20\n * years into the future belong to the current century, and the past 80 are in\n * the past.\n *\n * @param value - 2 digits in string format\n */\nexport function fourDigitYear(value: string): number {\n  const y = new Date().getFullYear()\n  const currentYear = y % 100\n  const century = Math.floor(y / 100)\n  const parsedYear = Number(value)\n  return (century + (parsedYear > currentYear + 20 ? -1 : 0)) * 100 + parsedYear\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given hour.\n * @param inputDate - A string or Date object\n */\nexport function hourEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setMinutes(59, 59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given hour.\n * @param inputDate - A string or Date object\n */\nexport function hourStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setMinutes(0, 0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given minute.\n * @param inputDate - A string or Date object\n */\nexport function minuteEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setSeconds(59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given minute.\n * @param inputDate - A string or Date object\n */\nexport function minuteStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setSeconds(0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the first day of a month.\n * @param inputDate - A string or Date object\n */\nexport function monthStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setDate(1)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Get the number of days in the given dates year.\n * @param inputDate - A string or Date object\n */\nexport function yearDays(inputDate: DateInput): number {\n  const d = date(inputDate)\n  return (\n    (new Date(d.getFullYear() + 1, 0, 0).getTime() -\n      new Date(d.getFullYear(), 0, 0).getTime()) /\n    86400000\n  )\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport { yearDays } from \"./yearDays\"\nimport { dayOfYear } from \"./dayOfYear\"\nimport { addDay } from \"./addDay\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Performs a bidirectional search for the nearest date that passes a function.\n * @param target - Performs a search for the nearest passing date.\n * @param search - The search function to use, given a date returns a boolean.\n * @param constraint - The number of iterations to perform before giving up, or logical constraint like \"month\", or \"week\".\n *\n */\nexport function nearestDay(\n  inputDate: DateInput,\n  search: (date: Date) => boolean,\n  constraint: number | \"month\" | \"week\" | \"year\" = 7\n): Date | null {\n  let increments: number\n  let decrements: number\n  const d = date(inputDate)\n  switch (constraint) {\n    case \"month\":\n      decrements = d.getDate()\n      increments = monthDays(d) - d.getDate()\n      break\n    case \"week\":\n      decrements = d.getDay() + 1\n      increments = 6 - d.getDay()\n      break\n    case \"year\":\n      const total = yearDays(d)\n      const day = dayOfYear(d)\n      decrements = day\n      increments = total - day\n      break\n    default:\n      increments = decrements = constraint\n  }\n\n  for (let i = 0; i <= increments || i < decrements; i++) {\n    if (i <= increments) {\n      const next = addDay(d, i)\n      if (search(next)) return next\n    }\n    if (i && i <= decrements) {\n      const prev = addDay(d, -i)\n      if (search(prev)) return prev\n    }\n  }\n  return null\n}\n","import { format } from \"./format\"\nimport { ap } from \"./ap\"\nimport type { FormatToken } from \"./types\"\n/**\n * Returns an array of options for a given token in a given locale.\n * @param token - Get the full range of options for a given token\n * @param locale - The locale to fetch the options for.\n */\nexport function range(\n  token: FormatToken,\n  locale = \"en\",\n  genitive = false\n): string[] {\n  const r: (n: number, c: (index: number) => string | number) => string[] = (\n    n,\n    c\n  ) =>\n    Array(n)\n      .fill(\"\")\n      .map((_, i) => `${c(i)}`)\n\n  if (token === \"M\") return r(12, (i) => i + 1)\n  if (token === \"MM\")\n    return r(12, (i) => {\n      const m = i + 1\n      return m < 10 ? `0${m}` : m\n    })\n  // MMM and MMMM\n  if (token.startsWith(\"M\"))\n    return range(\"MM\").map((m) =>\n      format(`2000-${m}-05`, token, locale, genitive)\n    )\n  if (token.startsWith(\"d\"))\n    return r(7, (i) => `0${i + 2}`).map((d) =>\n      format(`2022-10-${d}`, token, locale)\n    )\n  if (token === \"a\")\n    return [ap(\"am\", locale).toLowerCase(), ap(\"pm\", locale).toLowerCase()]\n  if (token === \"A\")\n    return [ap(\"am\", locale).toUpperCase(), ap(\"pm\", locale).toUpperCase()]\n  if (token.startsWith(\"Y\")) {\n    const year = new Date().getFullYear()\n    return r(120, (i) => i + 1).reduce(\n      (ranges, i) => {\n        if (i !== \"120\")\n          ranges.push(format(`${year + Number(i)}-06-06`, token, locale))\n        ranges.unshift(format(`${year - Number(i)}-06-06`, token, locale))\n        return ranges\n      },\n      [format(`${year}-06-06`, token, locale)]\n    )\n  }\n  if (token.startsWith(\"D\"))\n    return r(31, (i) => `${token === \"DD\" && i < 9 ? \"0\" : \"\"}${i + 1}`)\n  if (token.startsWith(\"H\"))\n    return r(24, (i) => `${token === \"HH\" && i < 10 ? \"0\" : \"\"}${i}`)\n  if (token.startsWith(\"h\"))\n    return r(12, (i) => `${token === \"hh\" && i < 9 ? \"0\" : \"\"}${i + 1}`)\n  if (token.startsWith(\"m\") || token.startsWith(\"s\"))\n    return r(60, (i) => `${token.length > 1 && i < 10 ? \"0\" : \"\"}${i}`)\n  return []\n}\n","import { date } from \"./date\"\nimport { validate, styles, fixedLength, four, two, validOffset, fixedLengthByOffset } from \"./common\"\nimport { formatStr } from \"./formatStr\"\nimport { fourDigitYear } from \"./fourDigitYear\"\nimport { ap } from \"./ap\"\nimport { range } from \"./range\"\nimport { monthDays } from \"./monthDays\"\nimport { parts } from \"./parts\"\nimport type {\n  ParseOptions,\n  Format,\n  Part,\n  FormatStyle,\n  FilledPart,\n  FormatToken,\n} from \"./types\"\n\nexport function parse(options: ParseOptions): Date | never\nexport function parse(\n  dateStr: string,\n  format?: Format,\n  locale?: string\n): Date | never\n/**\n * Parses a date string into a Date object using the given format.\n * @param dateStr - A string representing a date.\n * @param format - The format the given string is in.\n * @param locale - The locale to parse the string from.\n */\nexport function parse(\n  dateStrOrOptions: string | ParseOptions,\n  format: Format = \"ISO8601\",\n  locale = \"device\"\n): Date | never {\n  let partFilter: (part: Part) => boolean = () => true\n  let dateStr: string\n  let dateOverflow = \"backward\"\n  if (typeof dateStrOrOptions === \"object\") {\n    ;({\n      date: dateStr,\n      format = \"ISO8601\",\n      locale = \"device\",\n      dateOverflow = \"backward\",\n      partFilter = () => true,\n    } = dateStrOrOptions)\n  } else {\n    dateStr = dateStrOrOptions\n  }\n  if (!dateStr) throw new Error(\"parse() requires a date string.\")\n  const invalid = (): never => {\n    throw new Error(\n      `Date (${dateStr}) does not match format (${formatStr(format, locale)})`\n    )\n  }\n  if (format === \"ISO8601\") return date(dateStr)\n  const genitive =\n    styles.includes(format as FormatStyle) || typeof format === \"object\"\n  const formatParts = validate(parts(format, locale).filter(partFilter))\n  if (!formatParts.length) throw new Error(\"parse() requires a pattern.\")\n  let parsedParts\n  try {\n    parsedParts = parseParts(dateStr, formatParts)\n  } catch {\n    return invalid()\n  }\n  const now = new Date()\n  const parsed = new Map([\n    [\"YYYY\", now.getFullYear()],\n    [\"MM\", now.getMonth() + 1],\n    [\"DD\", now.getDate()],\n    [\"HH\", 0],\n    [\"mm\", 0],\n    [\"ss\", 0],\n  ])\n  let a: null | boolean = null\n  let offset = \"\"\n  parsedParts.forEach((part): void | never => {\n    if (part.partName === \"literal\") return\n    if (part.token === part.value) return invalid()\n    const v = Number(part.value)\n    if (parsed.has(part.token)) {\n      // Parse for YYYY, MM, DD, HH, hh, mm, ss, Z\n      parsed.set(part.token, v)\n    } else if (part.token === \"YY\") {\n      // Parse for YY\n      parsed.set(\"YYYY\", fourDigitYear(part.value))\n    } else {\n      /* MMM - Short name Jan-Dec\n       * MMMM - Full name January - December\n       * h - Minimum hour digits, 12 hour clock, 1-12\n       * hh - 2 hour digits, 12 hour clock, 01-12\n       * m - The minute 0-59\n       * mm - The minute 00-12\n       * s - The second 0-59\n       * a - am/pm\n       * A - AM/PM\n       */\n      const t = part.token\n      if (t.startsWith(\"d\")) {\n        // d, ddd, dddd we just ignore these because they are non specific\n        return\n      } else if (t === \"D\") {\n        parsed.set(\"DD\", v)\n      } else if (t === \"H\" || t.startsWith(\"h\")) {\n        parsed.set(\"HH\", v)\n      } else if (t === \"M\") {\n        parsed.set(\"MM\", v)\n      } else if (t === \"a\" || t === \"A\") {\n        a = part.value.toLowerCase() === ap(\"am\", locale).toLowerCase()\n      } else if (t === \"Z\" || t === \"ZZ\") {\n        offset = validOffset(part.value, t)\n      } else {\n        const values = range(t as FormatToken, locale, genitive)\n        const index = values.indexOf(part.value)\n        if (index !== -1) {\n          switch (t) {\n            case \"MMM\":\n            case \"MMMM\":\n              parsed.set(\"MM\", index + 1)\n              break\n          }\n        }\n      }\n    }\n  })\n  let hours = parsed.get(\"HH\") || 0\n  if (a === false) {\n    hours += hours === 12 ? 0 : 12\n    parsed.set(\"HH\", hours === 24 ? 0 : hours)\n  } else if (a === true && hours === 12) {\n    // 12am === 00 in 24 hour clock.\n    parsed.set(\"HH\", 0)\n  }\n  parsed.set(\"MM\", (parsed.get(\"MM\") || 1) - 1)\n  // eslint-disable-next-line prefer-const\n  let [Y, M, D, h, m, s] = Array.from(parsed.values())\n\n  // Determine if the date is valid for the month.\n  const maxDaysInMonth = monthDays(new Date(`${four(Y)}-${two(M + 1)}-10`))\n  if (maxDaysInMonth < D && dateOverflow === \"throw\")\n    throw new Error(`Invalid date ${four(Y)}-${two(M + 1)}-${two(D)}`)\n  D = dateOverflow === \"backward\" ? Math.min(D, maxDaysInMonth) : D\n\n  // Create the date.\n  const isoString = `${four(Y)}-${two(M + 1)}-${two(D)}T${two(h)}:${two(\n    m\n  )}:${two(s)}${offset}`\n  const d = new Date(isoString)\n  if (isFinite(+d)) return d\n  return invalid()\n}\n\n/**\n * Given a string date and corresponding format parts, fill the parts with the\n * data from the string.\n * @param dateStr - A string to parse.\n * @param formatParts - The expected parts of the given string.\n */\nexport function parseParts(dateStr: string, formatParts: Part[]): FilledPart[] {\n  let i = 0\n  const advance = (parts: Part[]): [Part, Part | undefined] => [\n    parts[i++],\n    parts[i],\n  ]\n  let pos = 0\n  const parsed: FilledPart[] = []\n  let n: undefined | Part = undefined\n  do {\n    const [current, next] = advance(formatParts)\n    n = next\n    let len = 1\n    if (current.partName === \"literal\") {\n      // Literals can be discarded\n      len = current.partValue.length\n    } else if (current.partName === \"timeZoneName\") {\n      len = fixedLengthByOffset(dateStr.substring(pos))\n    } else if (current.token in fixedLength) {\n      // Fixed length parse\n      len = fixedLength[current.token as keyof typeof fixedLength]\n    } else if (next) {\n      // Variable length parse.\n      if (next.partName === \"literal\") {\n        len = dateStr.indexOf(next.partValue, pos) - pos\n        if (len < 0) throw new Error()\n      } else if (next.partName === \"dayPeriod\") {\n        // Our validator is ensuring that the current item must be a variable\n        // length number. We need to extract it.\n        for (let i = 1; i <= 4; i++) {\n          if (isNaN(Number(dateStr.charAt(pos + i)))) {\n            len = i\n            break\n          }\n        }\n      } else {\n        // Our validator guarantees the next is either not a number or it\n        // will be the end of the string\n        const nextChar = dateStr.substring(pos).search(/\\d/)\n        if (nextChar !== -1) len = pos + nextChar\n      }\n    } else {\n      len = dateStr.length\n    }\n\n    parsed.push({ ...current, value: dateStr.substring(pos, pos + len) })\n    pos += len\n  } while (n)\n  return parsed\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same date. Ignores time.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameDay(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return (\n    a.getDate() === b.getDate() &&\n    a.getMonth() === b.getMonth() &&\n    a.getFullYear() === b.getFullYear()\n  )\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time seconds. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameSecond(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getSeconds() === b.getSeconds()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time minutes. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameMinute(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getMinutes() === b.getMinutes()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time hour. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameHour(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getHours() === b.getHours()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same year.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameYear(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getFullYear() === b.getFullYear()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given week. Defaults to Sunday as the\n * first day of the week:\n * 0 = Sunday ... 6 = Saturday\n * @param inputDate - A string or Date object\n * @param startOfWeekDay - Determines which day of the week is the first\n */\nexport function weekStart(inputDate: DateInput, startOfWeekDay = 0): Date {\n  const d = date(inputDate)\n  let diff = startOfWeekDay - d.getDay()\n  if (diff > 0) diff = diff - 7\n  d.setDate(d.getDate() + diff)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import { weekStart } from \"./weekStart\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the last day at the last second of the given week.\n * Defaults to Sunday as the first day of the week:\n * 0 = Sunday ... 6 = Saturday\n * @param inputDate -Gets the last day of the week\n * @param startOfWeekDay - The first day of the week\n */\nexport function weekEnd(inputDate: DateInput, startOfWeekDay = 0): Date {\n  const d = weekStart(inputDate, startOfWeekDay)\n  d.setDate(d.getDate() + 6)\n  d.setHours(23, 59, 59)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the start of the current year.\n * @param inputDate - A string or Date object\n */\nexport function yearStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n\n  d.setMonth(0)\n  d.setDate(1)\n  d.setHours(0, 0, 0)\n\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the end of the current year.\n * @param inputDate - A string or Date object\n */\nexport function yearEnd(inputDate: DateInput): Date {\n  const d = date(inputDate);\n\n  d.setMonth(11);\n  d.setDate(31);\n  d.setHours(23, 59, 59, 999);\n\n  return d;\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Is the first date before the second one?\n *\n * @param inputDate - The date that should be before the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is before the second date.\n */\nexport function isBefore(inputDate: DateInput, dateToCompare: DateInput) {\n  const _date = date(inputDate)\n  const _dateToCompare = date(dateToCompare)\n\n  return +_date < +_dateToCompare\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * @param inputDate - The date that should be after the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is after the second date.\n */\nexport function isAfter(inputDate: DateInput, dateToCompare: DateInput) {\n  const _date = date(inputDate)\n  const _dateToCompare = date(dateToCompare)\n\n  return +_date > +_dateToCompare\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Are the given dates equal?\n *\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n *\n * @returns The dates are equal.\n */\nexport function isEqual(dateLeft: DateInput, dateRight: DateInput) {\n  const _dateLeft = date(dateLeft)\n  const _dateRight = date(dateRight)\n\n  return +_dateLeft === +_dateRight\n}\n","import { date } from \"./date\"\nimport { DateInput } from \"./types\"\n\n/**\n * Returns the difference between 2 dates in milliseconds.\n * @param dateA A date to compare with the right date\n * @param dateB A date to compare with the left date\n */\nexport function diffMilliseconds(dateA: DateInput, dateB: DateInput) {\n  const left = date(dateA)\n  const right = date(dateB)\n  return +left - +right\n}\n","export type DiffRoundingMethod = \"trunc\" | \"round\" | \"floor\" | \"ceil\"\n\n/**\n * Return a rounded value with the given rounding method\n * @param value the value to round\n * @param method the rounding method\n */\nexport function diffRound(value: number, method: DiffRoundingMethod = \"trunc\") {\n  const r = Math[method](value)\n  return r == 0 ? 0 : r\n}\n","import { diffMilliseconds } from \"./diffMilliseconds\"\nimport { DiffRoundingMethod, diffRound } from \"./diffRound\"\nimport { DateInput } from \"./types\"\n\n/**\n * Returns the difference between 2 dates in seconds.\n * @param dateA A date to compare with the right date\n * @param dateB A date to compare with the left date\n * @param roundingMethod the rounding method to use, default: trunc\n */\nexport function diffSeconds(\n  dateA: DateInput,\n  dateB: DateInput,\n  roundingMethod?: DiffRoundingMethod\n) {\n  return diffRound(diffMilliseconds(dateA, dateB) / 1000, roundingMethod)\n}\n","import { DateInput } from \"./types\"\nimport { diffMilliseconds } from \"./diffMilliseconds\"\nimport { diffRound, type DiffRoundingMethod } from \"./diffRound\"\n\n/**\n * Returns the difference between 2 dates in minutes.\n * @param dateA A date to compare with the right date\n * @param roundingMethod the rounding method to use, default: trunc\n */\nexport function diffMinutes(\n  dateA: DateInput,\n  dateB: DateInput,\n  roundingMethod?: DiffRoundingMethod\n) {\n  return diffRound(diffMilliseconds(dateA, dateB) / 60_000, roundingMethod)\n}\n","import { diffMilliseconds } from \"./diffMilliseconds\"\nimport { diffRound, type DiffRoundingMethod } from \"./diffRound\"\nimport { DateInput } from \"./types\"\n\n/**\n * Returns the difference between 2 dates in hours.\n * @param dateA A date to compare with the right date\n * @param dateB A date to compare with the left date\n * @param roundingMethod the rounding method to use, default: trunc\n */\nexport function diffHours(\n  dateA: DateInput,\n  dateB: DateInput,\n  roundingMethod?: DiffRoundingMethod\n) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 3_600_000, // 1000 * 60 * 60\n    roundingMethod\n  )\n}\n","import { diffMilliseconds } from \"./diffMilliseconds\"\nimport { DateInput } from \"./types\"\nimport { diffRound, type DiffRoundingMethod } from \"./diffRound\"\n\n/**\n * Returns the difference between 2 dates in days.\n * @param dateA A date to compare with the right date\n * @param dateB A date to compare with the left date\n * @param roundingMethod the rounding method to use, default: trunc\n */\nexport function diffDays(\n  dateA: DateInput,\n  dateB: DateInput,\n  roundingMethod?: DiffRoundingMethod\n) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 86_400_000, // hour * 24\n    roundingMethod\n  )\n}\n","import { diffMilliseconds } from \"./diffMilliseconds\"\nimport { DateInput } from \"./types\"\nimport { diffRound, type DiffRoundingMethod } from \"./diffRound\"\n\n/**\n * Returns the difference between 2 dates in days.\n * @param dateA A date to compare with the right date\n * @param dateB A date to compare with the left date\n * @param roundingMethod the rounding method to use, default: trunc\n */\nexport function diffWeeks(\n  dateA: DateInput,\n  dateB: DateInput,\n  roundingMethod?: DiffRoundingMethod\n) {\n  return diffRound(\n    diffMilliseconds(dateA, dateB) / 604800000, // day * 7\n    roundingMethod\n  )\n}\n","import { date } from \"./date\"\nimport { DateInput } from \"./types\"\nimport { monthDays } from \"./monthDays\"\n\n/**\n * Returns the difference between 2 dates in months.\n * @param dateA A date to compare with the dateB date\n * @param dateB A date to compare with the dateA date\n */\nexport function diffMonths(dateA: DateInput, dateB: DateInput): number {\n  const l = date(dateA)\n  const r = date(dateB)\n  // if the dateB one is bigger, we switch them around as it's easier to do\n  if (l < r) {\n    const rs = diffMonths(r, l)\n    return rs == 0 ? 0 : -rs\n  }\n\n  // we first get the amount of calendar months\n  let months =\n    (l.getFullYear() - r.getFullYear()) * 12 + (l.getMonth() - r.getMonth())\n\n  const ld = l.getDate()\n  const rd = r.getDate()\n\n  // if no full month has passed we may subtract a month from the calendar months so we get the amount of full months\n  if (ld < rd) {\n    // in case dateA date is the last day of the month & the dateB date is higher, we don't subtract as a full month did actually pass\n    const lm = monthDays(l)\n    if (!(lm == ld && lm < rd)) {\n      months--\n    }\n  }\n  //ensures we don't give back -0\n  return months == 0 ? 0 : months\n}\n","import { diffMonths } from \"./diffMonths\"\nimport { DateInput } from \"./types\"\n\n/**\n * Returns the difference between 2 dates in years.\n * @param dateA A date to compare with the dateB date\n * @param dateB A date to compare with the dateA date\n */\nexport function diffYears(dateA: DateInput, dateB: DateInput): number {\n  const r = Math.trunc(diffMonths(dateA, dateB) / 12)\n  //ensures we don't give back -0\n  return r == 0 ? 0 : r\n}\n","{\n  \"events\": [\n    {\n      \"id\": 1,\n      \"name\": \"International Basler Cup\",\n      \"location\": \"Basel (SUI)\",\n      \"dateStart\": \"31.05.2024\",\n      \"dateEnd\": \"02.06.2024\",\n      \"link\": \"\"\n    },\n    {\n      \"id\": 2,\n      \"name\": \"European Aquatics Championships\",\n      \"location\": \"Belgrade (SRB)\",\n      \"dateStart\": \"17.06.2024\",\n      \"dateEnd\": \"23.06.2024\",\n      \"link\": \"https://www.len.eu/belgrade2024/\"\n    },\n    {\n      \"id\": 3,\n      \"name\": \"European Junior Swimming Championships\",\n      \"location\": \"Vilnius (LTU)\",\n      \"dateStart\": \"02.07.2024\",\n      \"dateEnd\": \"07.07.2024\",\n      \"link\": \"\"\n    },\n    {\n      \"id\": 4,\n      \"name\": \"Swiss Summer Championships\",\n      \"location\": \"Uster (SUI)\",\n      \"dateStart\": \"11.07.2024\",\n      \"dateEnd\": \"14.07.2024\",\n      \"link\": \"https://scu.ch/sm-50m-uster-2024/\"\n    },\n    {\n      \"id\": 5,\n      \"name\": \"Swiss Junior Championships\",\n      \"location\": \"Basel (SUI)\",\n      \"dateStart\": \"18.07.2024\",\n      \"dateEnd\": \"21.07.2024\",\n      \"link\": \"\"\n    },\n    {\n      \"id\": 6,\n      \"name\": \"The Olympic Games of Paris 2024\",\n      \"location\": \"Paris (FRA)\",\n      \"dateStart\": \"26.07.2024\",\n      \"dateEnd\": \"11.08.2024\",\n      \"link\": \"\"\n    }\n  ]\n}\n"],"names":["$bf2c1b6c50ba2843$var$iso8601Match","$bf2c1b6c50ba2843$export$324d90190a8b822a","date2","Date","d","setMilliseconds","$bf2c1b6c50ba2843$export$b65d57190c224ef2","matches","match","month","Number","date3","hours","trim","$bf2c1b6c50ba2843$var$normalize","Error","$bf2c1b6c50ba2843$var$specDate","$bf2c1b6c50ba2843$var$memoParts","Map","$bf2c1b6c50ba2843$var$clockAgnostic","year","day","weekday","minute","second","timeZoneName","$bf2c1b6c50ba2843$var$clock24","hour","$bf2c1b6c50ba2843$var$clock12","dayPeriod","$bf2c1b6c50ba2843$var$fixedLength","DD","HH","MM","YY","YYYY","hh","mm","ss","$bf2c1b6c50ba2843$var$fixedLengthByOffset","offsetString","test","$bf2c1b6c50ba2843$var$genitiveTokens","$bf2c1b6c50ba2843$var$tokens","map","format2","$bf2c1b6c50ba2843$var$dayPeriodMap","$bf2c1b6c50ba2843$var$styles","$bf2c1b6c50ba2843$var$two","n","String","padStart","$bf2c1b6c50ba2843$var$four","$bf2c1b6c50ba2843$var$normStr","part","type","value","normalize","$bf2c1b6c50ba2843$var$minsToOffset","timeDiffInMins","token","Math","floor","abs","mins","sign","$bf2c1b6c50ba2843$var$validOffset","offset2","token2","$bf2c1b6c50ba2843$export$2f6ca3d3b1f80bf5","ampm","locale","l","get","specimen","setUTCHours","period","subparts","Intl","DateTimeFormat","timeStyle","timeZone","hour12","formatToParts","find","localePeriods","set","Object","assign","$bf2c1b6c50ba2843$var$deviceTZ","resolvedOptions","$bf2c1b6c50ba2843$var$relativeTime","utcParts","hourCycle","parts2","forEach","$bf2c1b6c50ba2843$export$cc800923e997bb8","utcTime","tzA","tzB","timeZoneToken","_a","timeA","timeB","getTime","$bf2c1b6c50ba2843$export$6e2410c1d27f06e7","includes","$bf2c1b6c50ba2843$var$styleParts","options","dateStyle","date","time","formatter","segments","hourPart","hourTypeSegments","segment","hourType","partName","formatPattern","$bf2c1b6c50ba2843$var$guessPattern","partValue","length","isNaN","$bf2c1b6c50ba2843$var$partStyle","literal","RegExp","option","pattern","filter","f","testPattern","didAdd","replace","_","prefix","actualMatch","createPart","exp","keys","validate2","patterns","parts3","deduped","Set","size","found24Patterns","concat","bind","extractIndex","split","match2","hasIndex","has","weekdays","partStyles","formats2","i","style","setMonth","setDate","reduce","part2","genitiveMonth","genitiveFormattedParts","index","findIndex","formats","$bf2c1b6c50ba2843$export$d9468344d3651243","inputDateOrOptions","genitive","partFilter","tz","forceOffset","format","toISOString","toLowerCase","$bf2c1b6c50ba2843$export$6d0ed9f2778a193a","dateInput","positive","slice","$bf2c1b6c50ba2843$export$81d2e72c19d98397","$bf2c1b6c50ba2843$var$offsetToMins","offsetInMins","$bf2c1b6c50ba2843$var$fill","inputDate","partMap","$bf2c1b6c50ba2843$var$createPartMap","hour24","valueParts","genitiveParts","addValues","requestedParts","hour122","preciseLocale","push","formattedParts","genitiveFormattedPart","p","value2","getUTCHours","toUpperCase","getTimezoneOffset","join","$bf2c1b6c50ba2843$export$98e6a39c04603d36","dateStrOrOptions","dateStr","parsedParts","dateOverflow","invalid","$bf2c1b6c50ba2843$export$5c36e1133fcfd384","escapeLiterals","filterParts","str","sort","a","b","target","formatParts","$bf2c1b6c50ba2843$var$validate","lastPart","parseFloat","$bf2c1b6c50ba2843$var$isNumeric","$bf2c1b6c50ba2843$export$95928c105f9a7e7c","advance","pos","parsed","current","next","len","substring","indexOf","i2","charAt","nextChar","search","now","getFullYear","getMonth","getDate","v","$bf2c1b6c50ba2843$export$45d0834b23a18f0a","y","century","parsedYear","currentYear","t","startsWith","values","$bf2c1b6c50ba2843$export$d02631cccf789723","r","c","Array","fill","m","ranges","unshift","Y","M","D","h","s","from","maxDaysInMonth","$bf2c1b6c50ba2843$export$781108dca7b1e474","min","isFinite","$bf2c1b6c50ba2843$export$543488ac006ce21a","dateA","dateB","roundingMethod","$bf2c1b6c50ba2843$var$diffRound","method","$c0cccb4b7bc6b97b$exports","JSON","parse","$388b617130f03bd4$var$date","$388b617130f03bd4$var$day","$388b617130f03bd4$var$btnAdd","document","getElementById","$388b617130f03bd4$var$btnUpdate","$388b617130f03bd4$var$data","$388b617130f03bd4$var$eventsSection","$388b617130f03bd4$var$currentDateEl","$388b617130f03bd4$var$currentDayEl","$388b617130f03bd4$var$eventsListEl","$388b617130f03bd4$var$currentDate","$388b617130f03bd4$var$eventsLoadingEl","$388b617130f03bd4$var$listEvents","events","event","eventStartDate","dateStart","eventEndDate","dateEnd","startDate","endDate","countdown","daysPassed","console","log","name","id","link","location","insertAdjacentHTML","textContent","window","addEventListener","classList","remove","setTimeout","add","parts","offset","validate"],"version":3,"file":"index.6b43ebee.js.map"}